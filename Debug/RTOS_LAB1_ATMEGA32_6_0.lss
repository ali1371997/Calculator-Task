
RTOS_LAB1_ATMEGA32_6_0.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001636  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000030  00800060  00001636  000016ca  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002bf  00800090  00800090  000016fa  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000016fa  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000172c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002a0  00000000  00000000  00001768  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003505  00000000  00000000  00001a08  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000105d  00000000  00000000  00004f0d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001c3a  00000000  00000000  00005f6a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000764  00000000  00000000  00007ba4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000f51  00000000  00000000  00008308  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000029aa  00000000  00000000  00009259  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000002a8  00000000  00000000  0000bc03  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 eb 02 	jmp	0x5d6	; 0x5d6 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 e3       	ldi	r30, 0x36	; 54
      68:	f6 e1       	ldi	r31, 0x16	; 22
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a0 39       	cpi	r26, 0x90	; 144
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	23 e0       	ldi	r18, 0x03	; 3
      78:	a0 e9       	ldi	r26, 0x90	; 144
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	af 34       	cpi	r26, 0x4F	; 79
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 a6 05 	call	0xb4c	; 0xb4c <main>
      8a:	0c 94 19 0b 	jmp	0x1632	; 0x1632 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      92:	cf 93       	push	r28
      94:	df 93       	push	r29
      96:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
      98:	0e 94 3c 08 	call	0x1078	; 0x1078 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
      9c:	20 91 90 00 	lds	r18, 0x0090	; 0x800090 <__data_end>
      a0:	30 91 91 00 	lds	r19, 0x0091	; 0x800091 <__data_end+0x1>
      a4:	c9 01       	movw	r24, r18
      a6:	8c 0f       	add	r24, r28
      a8:	9d 1f       	adc	r25, r29
      aa:	88 35       	cpi	r24, 0x58	; 88
      ac:	42 e0       	ldi	r20, 0x02	; 2
      ae:	94 07       	cpc	r25, r20
      b0:	58 f4       	brcc	.+22     	; 0xc8 <pvPortMalloc+0x36>
      b2:	28 17       	cp	r18, r24
      b4:	39 07       	cpc	r19, r25
      b6:	58 f4       	brcc	.+22     	; 0xce <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
      b8:	e9 01       	movw	r28, r18
      ba:	ce 56       	subi	r28, 0x6E	; 110
      bc:	df 4f       	sbci	r29, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
      be:	90 93 91 00 	sts	0x0091, r25	; 0x800091 <__data_end+0x1>
      c2:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <__data_end>
      c6:	05 c0       	rjmp	.+10     	; 0xd2 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
      c8:	c0 e0       	ldi	r28, 0x00	; 0
      ca:	d0 e0       	ldi	r29, 0x00	; 0
      cc:	02 c0       	rjmp	.+4      	; 0xd2 <pvPortMalloc+0x40>
      ce:	c0 e0       	ldi	r28, 0x00	; 0
      d0:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
      d2:	0e 94 06 09 	call	0x120c	; 0x120c <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
      d6:	ce 01       	movw	r24, r28
      d8:	df 91       	pop	r29
      da:	cf 91       	pop	r28
      dc:	08 95       	ret

000000de <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
      de:	08 95       	ret

000000e0 <enableTrigger>:
//   data changes.
////////////////////////////////////////////////////////////////////
void enableTrigger(void)
{

	CLR_BIT(PORTB,2);
      e0:	c2 98       	cbi	0x18, 2	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
      e2:	89 ef       	ldi	r24, 0xF9	; 249
      e4:	90 e0       	ldi	r25, 0x00	; 0
      e6:	01 97       	sbiw	r24, 0x01	; 1
      e8:	f1 f7       	brne	.-4      	; 0xe6 <enableTrigger+0x6>
      ea:	00 c0       	rjmp	.+0      	; 0xec <enableTrigger+0xc>
      ec:	00 00       	nop
	
	_delay_ms(1);

	SET_BIT(PORTB,2);
      ee:	c2 9a       	sbi	0x18, 2	; 24
      f0:	8b ed       	ldi	r24, 0xDB	; 219
      f2:	95 e0       	ldi	r25, 0x05	; 5
      f4:	01 97       	sbiw	r24, 0x01	; 1
      f6:	f1 f7       	brne	.-4      	; 0xf4 <enableTrigger+0x14>
      f8:	00 c0       	rjmp	.+0      	; 0xfa <enableTrigger+0x1a>
      fa:	00 00       	nop
      fc:	08 95       	ret

000000fe <lcd_sendCommand>:
		
}


void lcd_sendCommand(unsigned char cmd)
{
      fe:	cf 93       	push	r28
     100:	c8 2f       	mov	r28, r24
	unsigned char high_nibble , low_nibble ; 		
	
	HIGH_NIBBLE(high_nibble,cmd);
	LOW_NIBBLE(low_nibble,cmd);

	CLR_BIT(PORTB,0); // to enable command mode 
     102:	c0 98       	cbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // write signal to lcd 
     104:	c1 98       	cbi	0x18, 1	; 24

	PORTB &=0x0f;
     106:	88 b3       	in	r24, 0x18	; 24
     108:	8f 70       	andi	r24, 0x0F	; 15
     10a:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble command  
     10c:	88 b3       	in	r24, 0x18	; 24
     10e:	9c 2f       	mov	r25, r28
     110:	90 7f       	andi	r25, 0xF0	; 240
     112:	89 2b       	or	r24, r25
     114:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
     116:	0e 94 70 00 	call	0xe0	; 0xe0 <enableTrigger>

	PORTB &=0x0f;
     11a:	88 b3       	in	r24, 0x18	; 24
     11c:	8f 70       	andi	r24, 0x0F	; 15
     11e:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble command 
     120:	88 b3       	in	r24, 0x18	; 24
     122:	c2 95       	swap	r28
     124:	c0 7f       	andi	r28, 0xF0	; 240
     126:	c8 2b       	or	r28, r24
     128:	c8 bb       	out	0x18, r28	; 24
	enableTrigger();
     12a:	0e 94 70 00 	call	0xe0	; 0xe0 <enableTrigger>

}
     12e:	cf 91       	pop	r28
     130:	08 95       	ret

00000132 <lcd_init>:
//							 and pinB.0 to pinB.2 o/p for control pins 
//////////////////////////////////////////////////////////////////////////////////////
void lcd_init(void)
{

	DDRB=0xff; // init port B as O/P port 
     132:	8f ef       	ldi	r24, 0xFF	; 255
     134:	87 bb       	out	0x17, r24	; 23
	PORTB=0x04; // activate LCD enable 
     136:	84 e0       	ldi	r24, 0x04	; 4
     138:	88 bb       	out	0x18, r24	; 24

	lcd_sendCommand(0x33); // 4-bit mode 
     13a:	83 e3       	ldi	r24, 0x33	; 51
     13c:	0e 94 7f 00 	call	0xfe	; 0xfe <lcd_sendCommand>
	lcd_sendCommand (0x32);
     140:	82 e3       	ldi	r24, 0x32	; 50
     142:	0e 94 7f 00 	call	0xfe	; 0xfe <lcd_sendCommand>
	lcd_sendCommand (0x28);
     146:	88 e2       	ldi	r24, 0x28	; 40
     148:	0e 94 7f 00 	call	0xfe	; 0xfe <lcd_sendCommand>



	lcd_sendCommand(0x0c); // turn on lcd 
     14c:	8c e0       	ldi	r24, 0x0C	; 12
     14e:	0e 94 7f 00 	call	0xfe	; 0xfe <lcd_sendCommand>
     152:	08 95       	ret

00000154 <lcd_displayChar>:
	enableTrigger();

}

void lcd_displayChar (unsigned char data)
{
     154:	cf 93       	push	r28
     156:	c8 2f       	mov	r28, r24

	unsigned char high_nibble , low_nibble ;

	SET_BIT(PORTB,0); //  enable data mode 
     158:	c0 9a       	sbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // activate lcd write 
     15a:	c1 98       	cbi	0x18, 1	; 24

	HIGH_NIBBLE(high_nibble,data); // get high nibble data 
	LOW_NIBBLE(low_nibble,data); // get low nibble data 
	
	PORTB &= 0x0f;
     15c:	88 b3       	in	r24, 0x18	; 24
     15e:	8f 70       	andi	r24, 0x0F	; 15
     160:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble data  
     162:	88 b3       	in	r24, 0x18	; 24
     164:	9c 2f       	mov	r25, r28
     166:	90 7f       	andi	r25, 0xF0	; 240
     168:	89 2b       	or	r24, r25
     16a:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
     16c:	0e 94 70 00 	call	0xe0	; 0xe0 <enableTrigger>
	
	PORTB &=0x0f;
     170:	88 b3       	in	r24, 0x18	; 24
     172:	8f 70       	andi	r24, 0x0F	; 15
     174:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble data 
     176:	88 b3       	in	r24, 0x18	; 24
     178:	c2 95       	swap	r28
     17a:	c0 7f       	andi	r28, 0xF0	; 240
     17c:	c8 2b       	or	r28, r24
     17e:	c8 bb       	out	0x18, r28	; 24
	enableTrigger();
     180:	0e 94 70 00 	call	0xe0	; 0xe0 <enableTrigger>
	

}
     184:	cf 91       	pop	r28
     186:	08 95       	ret

00000188 <lcd_gotoxy>:

void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
	 
	switch(y)
     188:	81 30       	cpi	r24, 0x01	; 1
     18a:	49 f0       	breq	.+18     	; 0x19e <lcd_gotoxy+0x16>
     18c:	28 f0       	brcs	.+10     	; 0x198 <lcd_gotoxy+0x10>
     18e:	82 30       	cpi	r24, 0x02	; 2
     190:	49 f0       	breq	.+18     	; 0x1a4 <lcd_gotoxy+0x1c>
     192:	83 30       	cpi	r24, 0x03	; 3
     194:	51 f0       	breq	.+20     	; 0x1aa <lcd_gotoxy+0x22>
     196:	0c c0       	rjmp	.+24     	; 0x1b0 <lcd_gotoxy+0x28>
	{
		case 0:

			position=position+x;
     198:	80 e8       	ldi	r24, 0x80	; 128
     19a:	86 0f       	add	r24, r22
					
		break;
     19c:	0a c0       	rjmp	.+20     	; 0x1b2 <lcd_gotoxy+0x2a>

		case 1:

			position=0xc0;
			position=position+x;
     19e:	80 ec       	ldi	r24, 0xC0	; 192
     1a0:	86 0f       	add	r24, r22

		break;
     1a2:	07 c0       	rjmp	.+14     	; 0x1b2 <lcd_gotoxy+0x2a>

		case 2:

			position=position+x;
     1a4:	80 e8       	ldi	r24, 0x80	; 128
     1a6:	86 0f       	add	r24, r22

		break;
     1a8:	04 c0       	rjmp	.+8      	; 0x1b2 <lcd_gotoxy+0x2a>

		case 3:
			position=position+x;
     1aa:	80 e8       	ldi	r24, 0x80	; 128
     1ac:	86 0f       	add	r24, r22
		break;
     1ae:	01 c0       	rjmp	.+2      	; 0x1b2 <lcd_gotoxy+0x2a>
}


void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
     1b0:	80 e8       	ldi	r24, 0x80	; 128
		break;
	
	
	}
	
	lcd_sendCommand(position); 	
     1b2:	0e 94 7f 00 	call	0xfe	; 0xfe <lcd_sendCommand>
     1b6:	08 95       	ret

000001b8 <lcd_clrScreen>:


void lcd_clrScreen(void)
{

	lcd_sendCommand(0x01);
     1b8:	81 e0       	ldi	r24, 0x01	; 1
     1ba:	0e 94 7f 00 	call	0xfe	; 0xfe <lcd_sendCommand>
     1be:	08 95       	ret

000001c0 <lcd_dispString>:

}


void lcd_dispString(char * ptr)
{
     1c0:	cf 93       	push	r28
     1c2:	df 93       	push	r29
     1c4:	ec 01       	movw	r28, r24

	while(* ptr!= '\0')
     1c6:	88 81       	ld	r24, Y
     1c8:	88 23       	and	r24, r24
     1ca:	31 f0       	breq	.+12     	; 0x1d8 <lcd_dispString+0x18>
     1cc:	21 96       	adiw	r28, 0x01	; 1
	{
		lcd_displayChar(* ptr);
     1ce:	0e 94 aa 00 	call	0x154	; 0x154 <lcd_displayChar>


void lcd_dispString(char * ptr)
{

	while(* ptr!= '\0')
     1d2:	89 91       	ld	r24, Y+
     1d4:	81 11       	cpse	r24, r1
     1d6:	fb cf       	rjmp	.-10     	; 0x1ce <lcd_dispString+0xe>
	
	}



}
     1d8:	df 91       	pop	r29
     1da:	cf 91       	pop	r28
     1dc:	08 95       	ret

000001de <lcd_disp_string_xy>:

void lcd_disp_string_xy(char * ptr , int y , int x)
{
     1de:	cf 93       	push	r28
     1e0:	df 93       	push	r29
     1e2:	ec 01       	movw	r28, r24
     1e4:	86 2f       	mov	r24, r22

	lcd_gotoxy(y,x);
     1e6:	64 2f       	mov	r22, r20
     1e8:	0e 94 c4 00 	call	0x188	; 0x188 <lcd_gotoxy>
	lcd_dispString(ptr);
     1ec:	ce 01       	movw	r24, r28
     1ee:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <lcd_dispString>

	


}
     1f2:	df 91       	pop	r29
     1f4:	cf 91       	pop	r28
     1f6:	08 95       	ret

000001f8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     1f8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     1fa:	03 96       	adiw	r24, 0x03	; 3
     1fc:	92 83       	std	Z+2, r25	; 0x02
     1fe:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     200:	2f ef       	ldi	r18, 0xFF	; 255
     202:	3f ef       	ldi	r19, 0xFF	; 255
     204:	34 83       	std	Z+4, r19	; 0x04
     206:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     208:	96 83       	std	Z+6, r25	; 0x06
     20a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     20c:	90 87       	std	Z+8, r25	; 0x08
     20e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     210:	10 82       	st	Z, r1
     212:	08 95       	ret

00000214 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     214:	fc 01       	movw	r30, r24
     216:	11 86       	std	Z+9, r1	; 0x09
     218:	10 86       	std	Z+8, r1	; 0x08
     21a:	08 95       	ret

0000021c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     21c:	cf 93       	push	r28
     21e:	df 93       	push	r29
     220:	fc 01       	movw	r30, r24
     222:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     224:	21 81       	ldd	r18, Z+1	; 0x01
     226:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     228:	e9 01       	movw	r28, r18
     22a:	8a 81       	ldd	r24, Y+2	; 0x02
     22c:	9b 81       	ldd	r25, Y+3	; 0x03
     22e:	13 96       	adiw	r26, 0x03	; 3
     230:	9c 93       	st	X, r25
     232:	8e 93       	st	-X, r24
     234:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     236:	81 81       	ldd	r24, Z+1	; 0x01
     238:	92 81       	ldd	r25, Z+2	; 0x02
     23a:	15 96       	adiw	r26, 0x05	; 5
     23c:	9c 93       	st	X, r25
     23e:	8e 93       	st	-X, r24
     240:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     242:	8a 81       	ldd	r24, Y+2	; 0x02
     244:	9b 81       	ldd	r25, Y+3	; 0x03
     246:	ec 01       	movw	r28, r24
     248:	7d 83       	std	Y+5, r23	; 0x05
     24a:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     24c:	e9 01       	movw	r28, r18
     24e:	7b 83       	std	Y+3, r23	; 0x03
     250:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     252:	72 83       	std	Z+2, r23	; 0x02
     254:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     256:	19 96       	adiw	r26, 0x09	; 9
     258:	fc 93       	st	X, r31
     25a:	ee 93       	st	-X, r30
     25c:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     25e:	80 81       	ld	r24, Z
     260:	8f 5f       	subi	r24, 0xFF	; 255
     262:	80 83       	st	Z, r24
}
     264:	df 91       	pop	r29
     266:	cf 91       	pop	r28
     268:	08 95       	ret

0000026a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     26a:	cf 93       	push	r28
     26c:	df 93       	push	r29
     26e:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     270:	48 81       	ld	r20, Y
     272:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     274:	4f 3f       	cpi	r20, 0xFF	; 255
     276:	2f ef       	ldi	r18, 0xFF	; 255
     278:	52 07       	cpc	r21, r18
     27a:	31 f4       	brne	.+12     	; 0x288 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     27c:	dc 01       	movw	r26, r24
     27e:	17 96       	adiw	r26, 0x07	; 7
     280:	ed 91       	ld	r30, X+
     282:	fc 91       	ld	r31, X
     284:	18 97       	sbiw	r26, 0x08	; 8
     286:	17 c0       	rjmp	.+46     	; 0x2b6 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     288:	fc 01       	movw	r30, r24
     28a:	33 96       	adiw	r30, 0x03	; 3
     28c:	dc 01       	movw	r26, r24
     28e:	15 96       	adiw	r26, 0x05	; 5
     290:	2d 91       	ld	r18, X+
     292:	3c 91       	ld	r19, X
     294:	16 97       	sbiw	r26, 0x06	; 6
     296:	d9 01       	movw	r26, r18
     298:	2d 91       	ld	r18, X+
     29a:	3c 91       	ld	r19, X
     29c:	42 17       	cp	r20, r18
     29e:	53 07       	cpc	r21, r19
     2a0:	50 f0       	brcs	.+20     	; 0x2b6 <vListInsert+0x4c>
     2a2:	02 80       	ldd	r0, Z+2	; 0x02
     2a4:	f3 81       	ldd	r31, Z+3	; 0x03
     2a6:	e0 2d       	mov	r30, r0
     2a8:	a2 81       	ldd	r26, Z+2	; 0x02
     2aa:	b3 81       	ldd	r27, Z+3	; 0x03
     2ac:	2d 91       	ld	r18, X+
     2ae:	3c 91       	ld	r19, X
     2b0:	42 17       	cp	r20, r18
     2b2:	53 07       	cpc	r21, r19
     2b4:	b0 f7       	brcc	.-20     	; 0x2a2 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     2b6:	a2 81       	ldd	r26, Z+2	; 0x02
     2b8:	b3 81       	ldd	r27, Z+3	; 0x03
     2ba:	bb 83       	std	Y+3, r27	; 0x03
     2bc:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     2be:	15 96       	adiw	r26, 0x05	; 5
     2c0:	dc 93       	st	X, r29
     2c2:	ce 93       	st	-X, r28
     2c4:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     2c6:	fd 83       	std	Y+5, r31	; 0x05
     2c8:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     2ca:	d3 83       	std	Z+3, r29	; 0x03
     2cc:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     2ce:	99 87       	std	Y+9, r25	; 0x09
     2d0:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     2d2:	fc 01       	movw	r30, r24
     2d4:	20 81       	ld	r18, Z
     2d6:	2f 5f       	subi	r18, 0xFF	; 255
     2d8:	20 83       	st	Z, r18
}
     2da:	df 91       	pop	r29
     2dc:	cf 91       	pop	r28
     2de:	08 95       	ret

000002e0 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     2e0:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     2e2:	a2 81       	ldd	r26, Z+2	; 0x02
     2e4:	b3 81       	ldd	r27, Z+3	; 0x03
     2e6:	84 81       	ldd	r24, Z+4	; 0x04
     2e8:	95 81       	ldd	r25, Z+5	; 0x05
     2ea:	15 96       	adiw	r26, 0x05	; 5
     2ec:	9c 93       	st	X, r25
     2ee:	8e 93       	st	-X, r24
     2f0:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     2f2:	a4 81       	ldd	r26, Z+4	; 0x04
     2f4:	b5 81       	ldd	r27, Z+5	; 0x05
     2f6:	82 81       	ldd	r24, Z+2	; 0x02
     2f8:	93 81       	ldd	r25, Z+3	; 0x03
     2fa:	13 96       	adiw	r26, 0x03	; 3
     2fc:	9c 93       	st	X, r25
     2fe:	8e 93       	st	-X, r24
     300:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     302:	a0 85       	ldd	r26, Z+8	; 0x08
     304:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     306:	11 96       	adiw	r26, 0x01	; 1
     308:	8d 91       	ld	r24, X+
     30a:	9c 91       	ld	r25, X
     30c:	12 97       	sbiw	r26, 0x02	; 2
     30e:	e8 17       	cp	r30, r24
     310:	f9 07       	cpc	r31, r25
     312:	31 f4       	brne	.+12     	; 0x320 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     314:	84 81       	ldd	r24, Z+4	; 0x04
     316:	95 81       	ldd	r25, Z+5	; 0x05
     318:	12 96       	adiw	r26, 0x02	; 2
     31a:	9c 93       	st	X, r25
     31c:	8e 93       	st	-X, r24
     31e:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     320:	11 86       	std	Z+9, r1	; 0x09
     322:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     324:	8c 91       	ld	r24, X
     326:	81 50       	subi	r24, 0x01	; 1
     328:	8c 93       	st	X, r24
     32a:	08 95       	ret

0000032c <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     32c:	31 e1       	ldi	r19, 0x11	; 17
     32e:	fc 01       	movw	r30, r24
     330:	30 83       	st	Z, r19
     332:	31 97       	sbiw	r30, 0x01	; 1
     334:	22 e2       	ldi	r18, 0x22	; 34
     336:	20 83       	st	Z, r18
     338:	31 97       	sbiw	r30, 0x01	; 1
     33a:	a3 e3       	ldi	r26, 0x33	; 51
     33c:	a0 83       	st	Z, r26
     33e:	31 97       	sbiw	r30, 0x01	; 1
     340:	60 83       	st	Z, r22
     342:	31 97       	sbiw	r30, 0x01	; 1
     344:	70 83       	st	Z, r23
     346:	31 97       	sbiw	r30, 0x01	; 1
     348:	10 82       	st	Z, r1
     34a:	31 97       	sbiw	r30, 0x01	; 1
     34c:	60 e8       	ldi	r22, 0x80	; 128
     34e:	60 83       	st	Z, r22
     350:	31 97       	sbiw	r30, 0x01	; 1
     352:	10 82       	st	Z, r1
     354:	31 97       	sbiw	r30, 0x01	; 1
     356:	62 e0       	ldi	r22, 0x02	; 2
     358:	60 83       	st	Z, r22
     35a:	31 97       	sbiw	r30, 0x01	; 1
     35c:	63 e0       	ldi	r22, 0x03	; 3
     35e:	60 83       	st	Z, r22
     360:	31 97       	sbiw	r30, 0x01	; 1
     362:	64 e0       	ldi	r22, 0x04	; 4
     364:	60 83       	st	Z, r22
     366:	31 97       	sbiw	r30, 0x01	; 1
     368:	65 e0       	ldi	r22, 0x05	; 5
     36a:	60 83       	st	Z, r22
     36c:	31 97       	sbiw	r30, 0x01	; 1
     36e:	66 e0       	ldi	r22, 0x06	; 6
     370:	60 83       	st	Z, r22
     372:	31 97       	sbiw	r30, 0x01	; 1
     374:	67 e0       	ldi	r22, 0x07	; 7
     376:	60 83       	st	Z, r22
     378:	31 97       	sbiw	r30, 0x01	; 1
     37a:	68 e0       	ldi	r22, 0x08	; 8
     37c:	60 83       	st	Z, r22
     37e:	31 97       	sbiw	r30, 0x01	; 1
     380:	69 e0       	ldi	r22, 0x09	; 9
     382:	60 83       	st	Z, r22
     384:	31 97       	sbiw	r30, 0x01	; 1
     386:	60 e1       	ldi	r22, 0x10	; 16
     388:	60 83       	st	Z, r22
     38a:	31 97       	sbiw	r30, 0x01	; 1
     38c:	30 83       	st	Z, r19
     38e:	31 97       	sbiw	r30, 0x01	; 1
     390:	32 e1       	ldi	r19, 0x12	; 18
     392:	30 83       	st	Z, r19
     394:	31 97       	sbiw	r30, 0x01	; 1
     396:	33 e1       	ldi	r19, 0x13	; 19
     398:	30 83       	st	Z, r19
     39a:	31 97       	sbiw	r30, 0x01	; 1
     39c:	34 e1       	ldi	r19, 0x14	; 20
     39e:	30 83       	st	Z, r19
     3a0:	31 97       	sbiw	r30, 0x01	; 1
     3a2:	35 e1       	ldi	r19, 0x15	; 21
     3a4:	30 83       	st	Z, r19
     3a6:	31 97       	sbiw	r30, 0x01	; 1
     3a8:	36 e1       	ldi	r19, 0x16	; 22
     3aa:	30 83       	st	Z, r19
     3ac:	31 97       	sbiw	r30, 0x01	; 1
     3ae:	37 e1       	ldi	r19, 0x17	; 23
     3b0:	30 83       	st	Z, r19
     3b2:	31 97       	sbiw	r30, 0x01	; 1
     3b4:	38 e1       	ldi	r19, 0x18	; 24
     3b6:	30 83       	st	Z, r19
     3b8:	31 97       	sbiw	r30, 0x01	; 1
     3ba:	39 e1       	ldi	r19, 0x19	; 25
     3bc:	30 83       	st	Z, r19
     3be:	31 97       	sbiw	r30, 0x01	; 1
     3c0:	30 e2       	ldi	r19, 0x20	; 32
     3c2:	30 83       	st	Z, r19
     3c4:	31 97       	sbiw	r30, 0x01	; 1
     3c6:	31 e2       	ldi	r19, 0x21	; 33
     3c8:	30 83       	st	Z, r19
     3ca:	31 97       	sbiw	r30, 0x01	; 1
     3cc:	20 83       	st	Z, r18
     3ce:	31 97       	sbiw	r30, 0x01	; 1
     3d0:	23 e2       	ldi	r18, 0x23	; 35
     3d2:	20 83       	st	Z, r18
     3d4:	31 97       	sbiw	r30, 0x01	; 1
     3d6:	40 83       	st	Z, r20
     3d8:	31 97       	sbiw	r30, 0x01	; 1
     3da:	50 83       	st	Z, r21
     3dc:	31 97       	sbiw	r30, 0x01	; 1
     3de:	26 e2       	ldi	r18, 0x26	; 38
     3e0:	20 83       	st	Z, r18
     3e2:	31 97       	sbiw	r30, 0x01	; 1
     3e4:	27 e2       	ldi	r18, 0x27	; 39
     3e6:	20 83       	st	Z, r18
     3e8:	31 97       	sbiw	r30, 0x01	; 1
     3ea:	28 e2       	ldi	r18, 0x28	; 40
     3ec:	20 83       	st	Z, r18
     3ee:	31 97       	sbiw	r30, 0x01	; 1
     3f0:	29 e2       	ldi	r18, 0x29	; 41
     3f2:	20 83       	st	Z, r18
     3f4:	31 97       	sbiw	r30, 0x01	; 1
     3f6:	20 e3       	ldi	r18, 0x30	; 48
     3f8:	20 83       	st	Z, r18
     3fa:	31 97       	sbiw	r30, 0x01	; 1
     3fc:	21 e3       	ldi	r18, 0x31	; 49
     3fe:	20 83       	st	Z, r18
     400:	86 97       	sbiw	r24, 0x26	; 38
     402:	08 95       	ret

00000404 <xPortStartScheduler>:
     404:	1b bc       	out	0x2b, r1	; 43
     406:	8c e7       	ldi	r24, 0x7C	; 124
     408:	8a bd       	out	0x2a, r24	; 42
     40a:	8b e0       	ldi	r24, 0x0B	; 11
     40c:	8e bd       	out	0x2e, r24	; 46
     40e:	89 b7       	in	r24, 0x39	; 57
     410:	80 61       	ori	r24, 0x10	; 16
     412:	89 bf       	out	0x39, r24	; 57
     414:	a0 91 4b 03 	lds	r26, 0x034B	; 0x80034b <pxCurrentTCB>
     418:	b0 91 4c 03 	lds	r27, 0x034C	; 0x80034c <pxCurrentTCB+0x1>
     41c:	cd 91       	ld	r28, X+
     41e:	cd bf       	out	0x3d, r28	; 61
     420:	dd 91       	ld	r29, X+
     422:	de bf       	out	0x3e, r29	; 62
     424:	ff 91       	pop	r31
     426:	ef 91       	pop	r30
     428:	df 91       	pop	r29
     42a:	cf 91       	pop	r28
     42c:	bf 91       	pop	r27
     42e:	af 91       	pop	r26
     430:	9f 91       	pop	r25
     432:	8f 91       	pop	r24
     434:	7f 91       	pop	r23
     436:	6f 91       	pop	r22
     438:	5f 91       	pop	r21
     43a:	4f 91       	pop	r20
     43c:	3f 91       	pop	r19
     43e:	2f 91       	pop	r18
     440:	1f 91       	pop	r17
     442:	0f 91       	pop	r16
     444:	ff 90       	pop	r15
     446:	ef 90       	pop	r14
     448:	df 90       	pop	r13
     44a:	cf 90       	pop	r12
     44c:	bf 90       	pop	r11
     44e:	af 90       	pop	r10
     450:	9f 90       	pop	r9
     452:	8f 90       	pop	r8
     454:	7f 90       	pop	r7
     456:	6f 90       	pop	r6
     458:	5f 90       	pop	r5
     45a:	4f 90       	pop	r4
     45c:	3f 90       	pop	r3
     45e:	2f 90       	pop	r2
     460:	1f 90       	pop	r1
     462:	0f 90       	pop	r0
     464:	0f be       	out	0x3f, r0	; 63
     466:	0f 90       	pop	r0
     468:	08 95       	ret
     46a:	81 e0       	ldi	r24, 0x01	; 1
     46c:	08 95       	ret

0000046e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     46e:	0f 92       	push	r0
     470:	0f b6       	in	r0, 0x3f	; 63
     472:	f8 94       	cli
     474:	0f 92       	push	r0
     476:	1f 92       	push	r1
     478:	11 24       	eor	r1, r1
     47a:	2f 92       	push	r2
     47c:	3f 92       	push	r3
     47e:	4f 92       	push	r4
     480:	5f 92       	push	r5
     482:	6f 92       	push	r6
     484:	7f 92       	push	r7
     486:	8f 92       	push	r8
     488:	9f 92       	push	r9
     48a:	af 92       	push	r10
     48c:	bf 92       	push	r11
     48e:	cf 92       	push	r12
     490:	df 92       	push	r13
     492:	ef 92       	push	r14
     494:	ff 92       	push	r15
     496:	0f 93       	push	r16
     498:	1f 93       	push	r17
     49a:	2f 93       	push	r18
     49c:	3f 93       	push	r19
     49e:	4f 93       	push	r20
     4a0:	5f 93       	push	r21
     4a2:	6f 93       	push	r22
     4a4:	7f 93       	push	r23
     4a6:	8f 93       	push	r24
     4a8:	9f 93       	push	r25
     4aa:	af 93       	push	r26
     4ac:	bf 93       	push	r27
     4ae:	cf 93       	push	r28
     4b0:	df 93       	push	r29
     4b2:	ef 93       	push	r30
     4b4:	ff 93       	push	r31
     4b6:	a0 91 4b 03 	lds	r26, 0x034B	; 0x80034b <pxCurrentTCB>
     4ba:	b0 91 4c 03 	lds	r27, 0x034C	; 0x80034c <pxCurrentTCB+0x1>
     4be:	0d b6       	in	r0, 0x3d	; 61
     4c0:	0d 92       	st	X+, r0
     4c2:	0e b6       	in	r0, 0x3e	; 62
     4c4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     4c6:	0e 94 be 09 	call	0x137c	; 0x137c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     4ca:	a0 91 4b 03 	lds	r26, 0x034B	; 0x80034b <pxCurrentTCB>
     4ce:	b0 91 4c 03 	lds	r27, 0x034C	; 0x80034c <pxCurrentTCB+0x1>
     4d2:	cd 91       	ld	r28, X+
     4d4:	cd bf       	out	0x3d, r28	; 61
     4d6:	dd 91       	ld	r29, X+
     4d8:	de bf       	out	0x3e, r29	; 62
     4da:	ff 91       	pop	r31
     4dc:	ef 91       	pop	r30
     4de:	df 91       	pop	r29
     4e0:	cf 91       	pop	r28
     4e2:	bf 91       	pop	r27
     4e4:	af 91       	pop	r26
     4e6:	9f 91       	pop	r25
     4e8:	8f 91       	pop	r24
     4ea:	7f 91       	pop	r23
     4ec:	6f 91       	pop	r22
     4ee:	5f 91       	pop	r21
     4f0:	4f 91       	pop	r20
     4f2:	3f 91       	pop	r19
     4f4:	2f 91       	pop	r18
     4f6:	1f 91       	pop	r17
     4f8:	0f 91       	pop	r16
     4fa:	ff 90       	pop	r15
     4fc:	ef 90       	pop	r14
     4fe:	df 90       	pop	r13
     500:	cf 90       	pop	r12
     502:	bf 90       	pop	r11
     504:	af 90       	pop	r10
     506:	9f 90       	pop	r9
     508:	8f 90       	pop	r8
     50a:	7f 90       	pop	r7
     50c:	6f 90       	pop	r6
     50e:	5f 90       	pop	r5
     510:	4f 90       	pop	r4
     512:	3f 90       	pop	r3
     514:	2f 90       	pop	r2
     516:	1f 90       	pop	r1
     518:	0f 90       	pop	r0
     51a:	0f be       	out	0x3f, r0	; 63
     51c:	0f 90       	pop	r0

	asm volatile ( "ret" );
     51e:	08 95       	ret

00000520 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     520:	0f 92       	push	r0
     522:	0f b6       	in	r0, 0x3f	; 63
     524:	f8 94       	cli
     526:	0f 92       	push	r0
     528:	1f 92       	push	r1
     52a:	11 24       	eor	r1, r1
     52c:	2f 92       	push	r2
     52e:	3f 92       	push	r3
     530:	4f 92       	push	r4
     532:	5f 92       	push	r5
     534:	6f 92       	push	r6
     536:	7f 92       	push	r7
     538:	8f 92       	push	r8
     53a:	9f 92       	push	r9
     53c:	af 92       	push	r10
     53e:	bf 92       	push	r11
     540:	cf 92       	push	r12
     542:	df 92       	push	r13
     544:	ef 92       	push	r14
     546:	ff 92       	push	r15
     548:	0f 93       	push	r16
     54a:	1f 93       	push	r17
     54c:	2f 93       	push	r18
     54e:	3f 93       	push	r19
     550:	4f 93       	push	r20
     552:	5f 93       	push	r21
     554:	6f 93       	push	r22
     556:	7f 93       	push	r23
     558:	8f 93       	push	r24
     55a:	9f 93       	push	r25
     55c:	af 93       	push	r26
     55e:	bf 93       	push	r27
     560:	cf 93       	push	r28
     562:	df 93       	push	r29
     564:	ef 93       	push	r30
     566:	ff 93       	push	r31
     568:	a0 91 4b 03 	lds	r26, 0x034B	; 0x80034b <pxCurrentTCB>
     56c:	b0 91 4c 03 	lds	r27, 0x034C	; 0x80034c <pxCurrentTCB+0x1>
     570:	0d b6       	in	r0, 0x3d	; 61
     572:	0d 92       	st	X+, r0
     574:	0e b6       	in	r0, 0x3e	; 62
     576:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     578:	0e 94 42 08 	call	0x1084	; 0x1084 <vTaskIncrementTick>
	vTaskSwitchContext();
     57c:	0e 94 be 09 	call	0x137c	; 0x137c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     580:	a0 91 4b 03 	lds	r26, 0x034B	; 0x80034b <pxCurrentTCB>
     584:	b0 91 4c 03 	lds	r27, 0x034C	; 0x80034c <pxCurrentTCB+0x1>
     588:	cd 91       	ld	r28, X+
     58a:	cd bf       	out	0x3d, r28	; 61
     58c:	dd 91       	ld	r29, X+
     58e:	de bf       	out	0x3e, r29	; 62
     590:	ff 91       	pop	r31
     592:	ef 91       	pop	r30
     594:	df 91       	pop	r29
     596:	cf 91       	pop	r28
     598:	bf 91       	pop	r27
     59a:	af 91       	pop	r26
     59c:	9f 91       	pop	r25
     59e:	8f 91       	pop	r24
     5a0:	7f 91       	pop	r23
     5a2:	6f 91       	pop	r22
     5a4:	5f 91       	pop	r21
     5a6:	4f 91       	pop	r20
     5a8:	3f 91       	pop	r19
     5aa:	2f 91       	pop	r18
     5ac:	1f 91       	pop	r17
     5ae:	0f 91       	pop	r16
     5b0:	ff 90       	pop	r15
     5b2:	ef 90       	pop	r14
     5b4:	df 90       	pop	r13
     5b6:	cf 90       	pop	r12
     5b8:	bf 90       	pop	r11
     5ba:	af 90       	pop	r10
     5bc:	9f 90       	pop	r9
     5be:	8f 90       	pop	r8
     5c0:	7f 90       	pop	r7
     5c2:	6f 90       	pop	r6
     5c4:	5f 90       	pop	r5
     5c6:	4f 90       	pop	r4
     5c8:	3f 90       	pop	r3
     5ca:	2f 90       	pop	r2
     5cc:	1f 90       	pop	r1
     5ce:	0f 90       	pop	r0
     5d0:	0f be       	out	0x3f, r0	; 63
     5d2:	0f 90       	pop	r0

	asm volatile ( "ret" );
     5d4:	08 95       	ret

000005d6 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void  TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void  TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     5d6:	0e 94 90 02 	call	0x520	; 0x520 <vPortYieldFromTick>
		asm volatile ( "reti" );
     5da:	18 95       	reti

000005dc <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     5dc:	cf 93       	push	r28
     5de:	df 93       	push	r29
     5e0:	ec 01       	movw	r28, r24
     5e2:	8c 8d       	ldd	r24, Y+28	; 0x1c
     5e4:	88 23       	and	r24, r24
     5e6:	a9 f1       	breq	.+106    	; 0x652 <prvCopyDataToQueue+0x76>
     5e8:	41 11       	cpse	r20, r1
     5ea:	17 c0       	rjmp	.+46     	; 0x61a <prvCopyDataToQueue+0x3e>
     5ec:	48 2f       	mov	r20, r24
     5ee:	50 e0       	ldi	r21, 0x00	; 0
     5f0:	8c 81       	ldd	r24, Y+4	; 0x04
     5f2:	9d 81       	ldd	r25, Y+5	; 0x05
     5f4:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <memcpy>
     5f8:	2c 8d       	ldd	r18, Y+28	; 0x1c
     5fa:	8c 81       	ldd	r24, Y+4	; 0x04
     5fc:	9d 81       	ldd	r25, Y+5	; 0x05
     5fe:	82 0f       	add	r24, r18
     600:	91 1d       	adc	r25, r1
     602:	9d 83       	std	Y+5, r25	; 0x05
     604:	8c 83       	std	Y+4, r24	; 0x04
     606:	2a 81       	ldd	r18, Y+2	; 0x02
     608:	3b 81       	ldd	r19, Y+3	; 0x03
     60a:	82 17       	cp	r24, r18
     60c:	93 07       	cpc	r25, r19
     60e:	08 f1       	brcs	.+66     	; 0x652 <prvCopyDataToQueue+0x76>
     610:	88 81       	ld	r24, Y
     612:	99 81       	ldd	r25, Y+1	; 0x01
     614:	9d 83       	std	Y+5, r25	; 0x05
     616:	8c 83       	std	Y+4, r24	; 0x04
     618:	1c c0       	rjmp	.+56     	; 0x652 <prvCopyDataToQueue+0x76>
     61a:	48 2f       	mov	r20, r24
     61c:	50 e0       	ldi	r21, 0x00	; 0
     61e:	8e 81       	ldd	r24, Y+6	; 0x06
     620:	9f 81       	ldd	r25, Y+7	; 0x07
     622:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <memcpy>
     626:	8c 8d       	ldd	r24, Y+28	; 0x1c
     628:	90 e0       	ldi	r25, 0x00	; 0
     62a:	91 95       	neg	r25
     62c:	81 95       	neg	r24
     62e:	91 09       	sbc	r25, r1
     630:	2e 81       	ldd	r18, Y+6	; 0x06
     632:	3f 81       	ldd	r19, Y+7	; 0x07
     634:	28 0f       	add	r18, r24
     636:	39 1f       	adc	r19, r25
     638:	3f 83       	std	Y+7, r19	; 0x07
     63a:	2e 83       	std	Y+6, r18	; 0x06
     63c:	48 81       	ld	r20, Y
     63e:	59 81       	ldd	r21, Y+1	; 0x01
     640:	24 17       	cp	r18, r20
     642:	35 07       	cpc	r19, r21
     644:	30 f4       	brcc	.+12     	; 0x652 <prvCopyDataToQueue+0x76>
     646:	2a 81       	ldd	r18, Y+2	; 0x02
     648:	3b 81       	ldd	r19, Y+3	; 0x03
     64a:	82 0f       	add	r24, r18
     64c:	93 1f       	adc	r25, r19
     64e:	9f 83       	std	Y+7, r25	; 0x07
     650:	8e 83       	std	Y+6, r24	; 0x06
     652:	8a 8d       	ldd	r24, Y+26	; 0x1a
     654:	8f 5f       	subi	r24, 0xFF	; 255
     656:	8a 8f       	std	Y+26, r24	; 0x1a
     658:	df 91       	pop	r29
     65a:	cf 91       	pop	r28
     65c:	08 95       	ret

0000065e <prvCopyDataFromQueue>:
     65e:	fc 01       	movw	r30, r24
     660:	80 81       	ld	r24, Z
     662:	91 81       	ldd	r25, Z+1	; 0x01
     664:	00 97       	sbiw	r24, 0x00	; 0
     666:	a1 f0       	breq	.+40     	; 0x690 <prvCopyDataFromQueue+0x32>
     668:	44 8d       	ldd	r20, Z+28	; 0x1c
     66a:	50 e0       	ldi	r21, 0x00	; 0
     66c:	26 81       	ldd	r18, Z+6	; 0x06
     66e:	37 81       	ldd	r19, Z+7	; 0x07
     670:	24 0f       	add	r18, r20
     672:	35 1f       	adc	r19, r21
     674:	37 83       	std	Z+7, r19	; 0x07
     676:	26 83       	std	Z+6, r18	; 0x06
     678:	a2 81       	ldd	r26, Z+2	; 0x02
     67a:	b3 81       	ldd	r27, Z+3	; 0x03
     67c:	2a 17       	cp	r18, r26
     67e:	3b 07       	cpc	r19, r27
     680:	10 f0       	brcs	.+4      	; 0x686 <prvCopyDataFromQueue+0x28>
     682:	97 83       	std	Z+7, r25	; 0x07
     684:	86 83       	std	Z+6, r24	; 0x06
     686:	cb 01       	movw	r24, r22
     688:	66 81       	ldd	r22, Z+6	; 0x06
     68a:	77 81       	ldd	r23, Z+7	; 0x07
     68c:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <memcpy>
     690:	08 95       	ret

00000692 <prvUnlockQueue>:
     692:	0f 93       	push	r16
     694:	1f 93       	push	r17
     696:	cf 93       	push	r28
     698:	df 93       	push	r29
     69a:	ec 01       	movw	r28, r24
     69c:	0f b6       	in	r0, 0x3f	; 63
     69e:	f8 94       	cli
     6a0:	0f 92       	push	r0
     6a2:	8e 8d       	ldd	r24, Y+30	; 0x1e
     6a4:	18 16       	cp	r1, r24
     6a6:	b4 f4       	brge	.+44     	; 0x6d4 <prvUnlockQueue+0x42>
     6a8:	89 89       	ldd	r24, Y+17	; 0x11
     6aa:	81 11       	cpse	r24, r1
     6ac:	05 c0       	rjmp	.+10     	; 0x6b8 <prvUnlockQueue+0x26>
     6ae:	12 c0       	rjmp	.+36     	; 0x6d4 <prvUnlockQueue+0x42>
     6b0:	89 89       	ldd	r24, Y+17	; 0x11
     6b2:	81 11       	cpse	r24, r1
     6b4:	04 c0       	rjmp	.+8      	; 0x6be <prvUnlockQueue+0x2c>
     6b6:	0e c0       	rjmp	.+28     	; 0x6d4 <prvUnlockQueue+0x42>
     6b8:	8e 01       	movw	r16, r28
     6ba:	0f 5e       	subi	r16, 0xEF	; 239
     6bc:	1f 4f       	sbci	r17, 0xFF	; 255
     6be:	c8 01       	movw	r24, r16
     6c0:	0e 94 47 0a 	call	0x148e	; 0x148e <xTaskRemoveFromEventList>
     6c4:	81 11       	cpse	r24, r1
     6c6:	0e 94 ce 0a 	call	0x159c	; 0x159c <vTaskMissedYield>
     6ca:	8e 8d       	ldd	r24, Y+30	; 0x1e
     6cc:	81 50       	subi	r24, 0x01	; 1
     6ce:	8e 8f       	std	Y+30, r24	; 0x1e
     6d0:	18 16       	cp	r1, r24
     6d2:	74 f3       	brlt	.-36     	; 0x6b0 <prvUnlockQueue+0x1e>
     6d4:	8f ef       	ldi	r24, 0xFF	; 255
     6d6:	8e 8f       	std	Y+30, r24	; 0x1e
     6d8:	0f 90       	pop	r0
     6da:	0f be       	out	0x3f, r0	; 63
     6dc:	0f b6       	in	r0, 0x3f	; 63
     6de:	f8 94       	cli
     6e0:	0f 92       	push	r0
     6e2:	8d 8d       	ldd	r24, Y+29	; 0x1d
     6e4:	18 16       	cp	r1, r24
     6e6:	b4 f4       	brge	.+44     	; 0x714 <prvUnlockQueue+0x82>
     6e8:	88 85       	ldd	r24, Y+8	; 0x08
     6ea:	81 11       	cpse	r24, r1
     6ec:	05 c0       	rjmp	.+10     	; 0x6f8 <prvUnlockQueue+0x66>
     6ee:	12 c0       	rjmp	.+36     	; 0x714 <prvUnlockQueue+0x82>
     6f0:	88 85       	ldd	r24, Y+8	; 0x08
     6f2:	81 11       	cpse	r24, r1
     6f4:	04 c0       	rjmp	.+8      	; 0x6fe <prvUnlockQueue+0x6c>
     6f6:	0e c0       	rjmp	.+28     	; 0x714 <prvUnlockQueue+0x82>
     6f8:	8e 01       	movw	r16, r28
     6fa:	08 5f       	subi	r16, 0xF8	; 248
     6fc:	1f 4f       	sbci	r17, 0xFF	; 255
     6fe:	c8 01       	movw	r24, r16
     700:	0e 94 47 0a 	call	0x148e	; 0x148e <xTaskRemoveFromEventList>
     704:	81 11       	cpse	r24, r1
     706:	0e 94 ce 0a 	call	0x159c	; 0x159c <vTaskMissedYield>
     70a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     70c:	81 50       	subi	r24, 0x01	; 1
     70e:	8d 8f       	std	Y+29, r24	; 0x1d
     710:	18 16       	cp	r1, r24
     712:	74 f3       	brlt	.-36     	; 0x6f0 <prvUnlockQueue+0x5e>
     714:	8f ef       	ldi	r24, 0xFF	; 255
     716:	8d 8f       	std	Y+29, r24	; 0x1d
     718:	0f 90       	pop	r0
     71a:	0f be       	out	0x3f, r0	; 63
     71c:	df 91       	pop	r29
     71e:	cf 91       	pop	r28
     720:	1f 91       	pop	r17
     722:	0f 91       	pop	r16
     724:	08 95       	ret

00000726 <xQueueCreate>:
     726:	cf 92       	push	r12
     728:	df 92       	push	r13
     72a:	ef 92       	push	r14
     72c:	ff 92       	push	r15
     72e:	0f 93       	push	r16
     730:	1f 93       	push	r17
     732:	cf 93       	push	r28
     734:	df 93       	push	r29
     736:	88 23       	and	r24, r24
     738:	d1 f1       	breq	.+116    	; 0x7ae <xQueueCreate+0x88>
     73a:	e6 2e       	mov	r14, r22
     73c:	f8 2e       	mov	r15, r24
     73e:	8f e1       	ldi	r24, 0x1F	; 31
     740:	90 e0       	ldi	r25, 0x00	; 0
     742:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     746:	ec 01       	movw	r28, r24
     748:	89 2b       	or	r24, r25
     74a:	99 f1       	breq	.+102    	; 0x7b2 <xQueueCreate+0x8c>
     74c:	ce 2c       	mov	r12, r14
     74e:	d1 2c       	mov	r13, r1
     750:	fc 9c       	mul	r15, r12
     752:	80 01       	movw	r16, r0
     754:	fd 9c       	mul	r15, r13
     756:	10 0d       	add	r17, r0
     758:	11 24       	eor	r1, r1
     75a:	c8 01       	movw	r24, r16
     75c:	01 96       	adiw	r24, 0x01	; 1
     75e:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     762:	99 83       	std	Y+1, r25	; 0x01
     764:	88 83       	st	Y, r24
     766:	00 97       	sbiw	r24, 0x00	; 0
     768:	e1 f0       	breq	.+56     	; 0x7a2 <xQueueCreate+0x7c>
     76a:	9c 01       	movw	r18, r24
     76c:	20 0f       	add	r18, r16
     76e:	31 1f       	adc	r19, r17
     770:	3b 83       	std	Y+3, r19	; 0x03
     772:	2a 83       	std	Y+2, r18	; 0x02
     774:	1a 8e       	std	Y+26, r1	; 0x1a
     776:	9d 83       	std	Y+5, r25	; 0x05
     778:	8c 83       	std	Y+4, r24	; 0x04
     77a:	0c 19       	sub	r16, r12
     77c:	1d 09       	sbc	r17, r13
     77e:	08 0f       	add	r16, r24
     780:	19 1f       	adc	r17, r25
     782:	1f 83       	std	Y+7, r17	; 0x07
     784:	0e 83       	std	Y+6, r16	; 0x06
     786:	fb 8e       	std	Y+27, r15	; 0x1b
     788:	ec 8e       	std	Y+28, r14	; 0x1c
     78a:	8f ef       	ldi	r24, 0xFF	; 255
     78c:	8d 8f       	std	Y+29, r24	; 0x1d
     78e:	8e 8f       	std	Y+30, r24	; 0x1e
     790:	ce 01       	movw	r24, r28
     792:	08 96       	adiw	r24, 0x08	; 8
     794:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <vListInitialise>
     798:	ce 01       	movw	r24, r28
     79a:	41 96       	adiw	r24, 0x11	; 17
     79c:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <vListInitialise>
     7a0:	08 c0       	rjmp	.+16     	; 0x7b2 <xQueueCreate+0x8c>
     7a2:	ce 01       	movw	r24, r28
     7a4:	0e 94 6f 00 	call	0xde	; 0xde <vPortFree>
     7a8:	c0 e0       	ldi	r28, 0x00	; 0
     7aa:	d0 e0       	ldi	r29, 0x00	; 0
     7ac:	02 c0       	rjmp	.+4      	; 0x7b2 <xQueueCreate+0x8c>
     7ae:	c0 e0       	ldi	r28, 0x00	; 0
     7b0:	d0 e0       	ldi	r29, 0x00	; 0
     7b2:	ce 01       	movw	r24, r28
     7b4:	df 91       	pop	r29
     7b6:	cf 91       	pop	r28
     7b8:	1f 91       	pop	r17
     7ba:	0f 91       	pop	r16
     7bc:	ff 90       	pop	r15
     7be:	ef 90       	pop	r14
     7c0:	df 90       	pop	r13
     7c2:	cf 90       	pop	r12
     7c4:	08 95       	ret

000007c6 <xQueueGenericSend>:
     7c6:	9f 92       	push	r9
     7c8:	af 92       	push	r10
     7ca:	bf 92       	push	r11
     7cc:	cf 92       	push	r12
     7ce:	df 92       	push	r13
     7d0:	ef 92       	push	r14
     7d2:	ff 92       	push	r15
     7d4:	0f 93       	push	r16
     7d6:	1f 93       	push	r17
     7d8:	cf 93       	push	r28
     7da:	df 93       	push	r29
     7dc:	00 d0       	rcall	.+0      	; 0x7de <xQueueGenericSend+0x18>
     7de:	00 d0       	rcall	.+0      	; 0x7e0 <xQueueGenericSend+0x1a>
     7e0:	1f 92       	push	r1
     7e2:	cd b7       	in	r28, 0x3d	; 61
     7e4:	de b7       	in	r29, 0x3e	; 62
     7e6:	8c 01       	movw	r16, r24
     7e8:	6b 01       	movw	r12, r22
     7ea:	5d 83       	std	Y+5, r21	; 0x05
     7ec:	4c 83       	std	Y+4, r20	; 0x04
     7ee:	92 2e       	mov	r9, r18
     7f0:	b1 2c       	mov	r11, r1
     7f2:	aa 24       	eor	r10, r10
     7f4:	a3 94       	inc	r10
     7f6:	7c 01       	movw	r14, r24
     7f8:	88 e0       	ldi	r24, 0x08	; 8
     7fa:	e8 0e       	add	r14, r24
     7fc:	f1 1c       	adc	r15, r1
     7fe:	0f b6       	in	r0, 0x3f	; 63
     800:	f8 94       	cli
     802:	0f 92       	push	r0
     804:	f8 01       	movw	r30, r16
     806:	92 8d       	ldd	r25, Z+26	; 0x1a
     808:	83 8d       	ldd	r24, Z+27	; 0x1b
     80a:	98 17       	cp	r25, r24
     80c:	a8 f4       	brcc	.+42     	; 0x838 <xQueueGenericSend+0x72>
     80e:	49 2d       	mov	r20, r9
     810:	b6 01       	movw	r22, r12
     812:	c8 01       	movw	r24, r16
     814:	0e 94 ee 02 	call	0x5dc	; 0x5dc <prvCopyDataToQueue>
     818:	f8 01       	movw	r30, r16
     81a:	81 89       	ldd	r24, Z+17	; 0x11
     81c:	88 23       	and	r24, r24
     81e:	41 f0       	breq	.+16     	; 0x830 <xQueueGenericSend+0x6a>
     820:	c8 01       	movw	r24, r16
     822:	41 96       	adiw	r24, 0x11	; 17
     824:	0e 94 47 0a 	call	0x148e	; 0x148e <xTaskRemoveFromEventList>
     828:	81 30       	cpi	r24, 0x01	; 1
     82a:	11 f4       	brne	.+4      	; 0x830 <xQueueGenericSend+0x6a>
     82c:	0e 94 37 02 	call	0x46e	; 0x46e <vPortYield>
     830:	0f 90       	pop	r0
     832:	0f be       	out	0x3f, r0	; 63
     834:	81 e0       	ldi	r24, 0x01	; 1
     836:	50 c0       	rjmp	.+160    	; 0x8d8 <__stack+0x79>
     838:	8c 81       	ldd	r24, Y+4	; 0x04
     83a:	9d 81       	ldd	r25, Y+5	; 0x05
     83c:	89 2b       	or	r24, r25
     83e:	21 f4       	brne	.+8      	; 0x848 <xQueueGenericSend+0x82>
     840:	0f 90       	pop	r0
     842:	0f be       	out	0x3f, r0	; 63
     844:	80 e0       	ldi	r24, 0x00	; 0
     846:	48 c0       	rjmp	.+144    	; 0x8d8 <__stack+0x79>
     848:	b1 10       	cpse	r11, r1
     84a:	05 c0       	rjmp	.+10     	; 0x856 <xQueueGenericSend+0x90>
     84c:	ce 01       	movw	r24, r28
     84e:	01 96       	adiw	r24, 0x01	; 1
     850:	0e 94 8c 0a 	call	0x1518	; 0x1518 <vTaskSetTimeOutState>
     854:	ba 2c       	mov	r11, r10
     856:	0f 90       	pop	r0
     858:	0f be       	out	0x3f, r0	; 63
     85a:	0e 94 3c 08 	call	0x1078	; 0x1078 <vTaskSuspendAll>
     85e:	0f b6       	in	r0, 0x3f	; 63
     860:	f8 94       	cli
     862:	0f 92       	push	r0
     864:	f8 01       	movw	r30, r16
     866:	85 8d       	ldd	r24, Z+29	; 0x1d
     868:	8f 3f       	cpi	r24, 0xFF	; 255
     86a:	09 f4       	brne	.+2      	; 0x86e <__stack+0xf>
     86c:	15 8e       	std	Z+29, r1	; 0x1d
     86e:	f8 01       	movw	r30, r16
     870:	86 8d       	ldd	r24, Z+30	; 0x1e
     872:	8f 3f       	cpi	r24, 0xFF	; 255
     874:	09 f4       	brne	.+2      	; 0x878 <__stack+0x19>
     876:	16 8e       	std	Z+30, r1	; 0x1e
     878:	0f 90       	pop	r0
     87a:	0f be       	out	0x3f, r0	; 63
     87c:	be 01       	movw	r22, r28
     87e:	6c 5f       	subi	r22, 0xFC	; 252
     880:	7f 4f       	sbci	r23, 0xFF	; 255
     882:	ce 01       	movw	r24, r28
     884:	01 96       	adiw	r24, 0x01	; 1
     886:	0e 94 97 0a 	call	0x152e	; 0x152e <xTaskCheckForTimeOut>
     88a:	81 11       	cpse	r24, r1
     88c:	1f c0       	rjmp	.+62     	; 0x8cc <__stack+0x6d>
     88e:	0f b6       	in	r0, 0x3f	; 63
     890:	f8 94       	cli
     892:	0f 92       	push	r0
     894:	f8 01       	movw	r30, r16
     896:	92 8d       	ldd	r25, Z+26	; 0x1a
     898:	0f 90       	pop	r0
     89a:	0f be       	out	0x3f, r0	; 63
     89c:	83 8d       	ldd	r24, Z+27	; 0x1b
     89e:	98 13       	cpse	r25, r24
     8a0:	0f c0       	rjmp	.+30     	; 0x8c0 <__stack+0x61>
     8a2:	6c 81       	ldd	r22, Y+4	; 0x04
     8a4:	7d 81       	ldd	r23, Y+5	; 0x05
     8a6:	c7 01       	movw	r24, r14
     8a8:	0e 94 2a 0a 	call	0x1454	; 0x1454 <vTaskPlaceOnEventList>
     8ac:	c8 01       	movw	r24, r16
     8ae:	0e 94 49 03 	call	0x692	; 0x692 <prvUnlockQueue>
     8b2:	0e 94 06 09 	call	0x120c	; 0x120c <xTaskResumeAll>
     8b6:	81 11       	cpse	r24, r1
     8b8:	a2 cf       	rjmp	.-188    	; 0x7fe <xQueueGenericSend+0x38>
     8ba:	0e 94 37 02 	call	0x46e	; 0x46e <vPortYield>
     8be:	9f cf       	rjmp	.-194    	; 0x7fe <xQueueGenericSend+0x38>
     8c0:	c8 01       	movw	r24, r16
     8c2:	0e 94 49 03 	call	0x692	; 0x692 <prvUnlockQueue>
     8c6:	0e 94 06 09 	call	0x120c	; 0x120c <xTaskResumeAll>
     8ca:	99 cf       	rjmp	.-206    	; 0x7fe <xQueueGenericSend+0x38>
     8cc:	c8 01       	movw	r24, r16
     8ce:	0e 94 49 03 	call	0x692	; 0x692 <prvUnlockQueue>
     8d2:	0e 94 06 09 	call	0x120c	; 0x120c <xTaskResumeAll>
     8d6:	80 e0       	ldi	r24, 0x00	; 0
     8d8:	0f 90       	pop	r0
     8da:	0f 90       	pop	r0
     8dc:	0f 90       	pop	r0
     8de:	0f 90       	pop	r0
     8e0:	0f 90       	pop	r0
     8e2:	df 91       	pop	r29
     8e4:	cf 91       	pop	r28
     8e6:	1f 91       	pop	r17
     8e8:	0f 91       	pop	r16
     8ea:	ff 90       	pop	r15
     8ec:	ef 90       	pop	r14
     8ee:	df 90       	pop	r13
     8f0:	cf 90       	pop	r12
     8f2:	bf 90       	pop	r11
     8f4:	af 90       	pop	r10
     8f6:	9f 90       	pop	r9
     8f8:	08 95       	ret

000008fa <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     8fa:	9f 92       	push	r9
     8fc:	af 92       	push	r10
     8fe:	bf 92       	push	r11
     900:	cf 92       	push	r12
     902:	df 92       	push	r13
     904:	ef 92       	push	r14
     906:	ff 92       	push	r15
     908:	0f 93       	push	r16
     90a:	1f 93       	push	r17
     90c:	cf 93       	push	r28
     90e:	df 93       	push	r29
     910:	00 d0       	rcall	.+0      	; 0x912 <xQueueGenericReceive+0x18>
     912:	00 d0       	rcall	.+0      	; 0x914 <xQueueGenericReceive+0x1a>
     914:	1f 92       	push	r1
     916:	cd b7       	in	r28, 0x3d	; 61
     918:	de b7       	in	r29, 0x3e	; 62
     91a:	8c 01       	movw	r16, r24
     91c:	6b 01       	movw	r12, r22
     91e:	5d 83       	std	Y+5, r21	; 0x05
     920:	4c 83       	std	Y+4, r20	; 0x04
     922:	92 2e       	mov	r9, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     924:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     926:	aa 24       	eor	r10, r10
     928:	a3 94       	inc	r10
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     92a:	7c 01       	movw	r14, r24
     92c:	81 e1       	ldi	r24, 0x11	; 17
     92e:	e8 0e       	add	r14, r24
     930:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     932:	0f b6       	in	r0, 0x3f	; 63
     934:	f8 94       	cli
     936:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     938:	f8 01       	movw	r30, r16
     93a:	82 8d       	ldd	r24, Z+26	; 0x1a
     93c:	88 23       	and	r24, r24
     93e:	49 f1       	breq	.+82     	; 0x992 <xQueueGenericReceive+0x98>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     940:	e6 80       	ldd	r14, Z+6	; 0x06
     942:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     944:	b6 01       	movw	r22, r12
     946:	c8 01       	movw	r24, r16
     948:	0e 94 2f 03 	call	0x65e	; 0x65e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     94c:	91 10       	cpse	r9, r1
     94e:	10 c0       	rjmp	.+32     	; 0x970 <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     950:	f8 01       	movw	r30, r16
     952:	82 8d       	ldd	r24, Z+26	; 0x1a
     954:	81 50       	subi	r24, 0x01	; 1
     956:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     958:	80 85       	ldd	r24, Z+8	; 0x08
     95a:	88 23       	and	r24, r24
     95c:	b1 f0       	breq	.+44     	; 0x98a <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     95e:	c8 01       	movw	r24, r16
     960:	08 96       	adiw	r24, 0x08	; 8
     962:	0e 94 47 0a 	call	0x148e	; 0x148e <xTaskRemoveFromEventList>
     966:	81 30       	cpi	r24, 0x01	; 1
     968:	81 f4       	brne	.+32     	; 0x98a <xQueueGenericReceive+0x90>
						{
							portYIELD_WITHIN_API();
     96a:	0e 94 37 02 	call	0x46e	; 0x46e <vPortYield>
     96e:	0d c0       	rjmp	.+26     	; 0x98a <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     970:	f8 01       	movw	r30, r16
     972:	f7 82       	std	Z+7, r15	; 0x07
     974:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     976:	81 89       	ldd	r24, Z+17	; 0x11
     978:	88 23       	and	r24, r24
     97a:	39 f0       	breq	.+14     	; 0x98a <xQueueGenericReceive+0x90>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     97c:	c8 01       	movw	r24, r16
     97e:	41 96       	adiw	r24, 0x11	; 17
     980:	0e 94 47 0a 	call	0x148e	; 0x148e <xTaskRemoveFromEventList>
     984:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
     986:	0e 94 37 02 	call	0x46e	; 0x46e <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
     98a:	0f 90       	pop	r0
     98c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     98e:	81 e0       	ldi	r24, 0x01	; 1
     990:	4f c0       	rjmp	.+158    	; 0xa30 <xQueueGenericReceive+0x136>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     992:	8c 81       	ldd	r24, Y+4	; 0x04
     994:	9d 81       	ldd	r25, Y+5	; 0x05
     996:	89 2b       	or	r24, r25
     998:	21 f4       	brne	.+8      	; 0x9a2 <xQueueGenericReceive+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     99a:	0f 90       	pop	r0
     99c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     99e:	80 e0       	ldi	r24, 0x00	; 0
     9a0:	47 c0       	rjmp	.+142    	; 0xa30 <xQueueGenericReceive+0x136>
				}
				else if( xEntryTimeSet == pdFALSE )
     9a2:	b1 10       	cpse	r11, r1
     9a4:	05 c0       	rjmp	.+10     	; 0x9b0 <xQueueGenericReceive+0xb6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     9a6:	ce 01       	movw	r24, r28
     9a8:	01 96       	adiw	r24, 0x01	; 1
     9aa:	0e 94 8c 0a 	call	0x1518	; 0x1518 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     9ae:	ba 2c       	mov	r11, r10
				}
			}
		}
		taskEXIT_CRITICAL();
     9b0:	0f 90       	pop	r0
     9b2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     9b4:	0e 94 3c 08 	call	0x1078	; 0x1078 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     9b8:	0f b6       	in	r0, 0x3f	; 63
     9ba:	f8 94       	cli
     9bc:	0f 92       	push	r0
     9be:	f8 01       	movw	r30, r16
     9c0:	85 8d       	ldd	r24, Z+29	; 0x1d
     9c2:	8f 3f       	cpi	r24, 0xFF	; 255
     9c4:	09 f4       	brne	.+2      	; 0x9c8 <xQueueGenericReceive+0xce>
     9c6:	15 8e       	std	Z+29, r1	; 0x1d
     9c8:	f8 01       	movw	r30, r16
     9ca:	86 8d       	ldd	r24, Z+30	; 0x1e
     9cc:	8f 3f       	cpi	r24, 0xFF	; 255
     9ce:	09 f4       	brne	.+2      	; 0x9d2 <xQueueGenericReceive+0xd8>
     9d0:	16 8e       	std	Z+30, r1	; 0x1e
     9d2:	0f 90       	pop	r0
     9d4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     9d6:	be 01       	movw	r22, r28
     9d8:	6c 5f       	subi	r22, 0xFC	; 252
     9da:	7f 4f       	sbci	r23, 0xFF	; 255
     9dc:	ce 01       	movw	r24, r28
     9de:	01 96       	adiw	r24, 0x01	; 1
     9e0:	0e 94 97 0a 	call	0x152e	; 0x152e <xTaskCheckForTimeOut>
     9e4:	81 11       	cpse	r24, r1
     9e6:	1e c0       	rjmp	.+60     	; 0xa24 <xQueueGenericReceive+0x12a>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     9e8:	0f b6       	in	r0, 0x3f	; 63
     9ea:	f8 94       	cli
     9ec:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     9ee:	f8 01       	movw	r30, r16
     9f0:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     9f2:	0f 90       	pop	r0
     9f4:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     9f6:	81 11       	cpse	r24, r1
     9f8:	0f c0       	rjmp	.+30     	; 0xa18 <xQueueGenericReceive+0x11e>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     9fa:	6c 81       	ldd	r22, Y+4	; 0x04
     9fc:	7d 81       	ldd	r23, Y+5	; 0x05
     9fe:	c7 01       	movw	r24, r14
     a00:	0e 94 2a 0a 	call	0x1454	; 0x1454 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     a04:	c8 01       	movw	r24, r16
     a06:	0e 94 49 03 	call	0x692	; 0x692 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     a0a:	0e 94 06 09 	call	0x120c	; 0x120c <xTaskResumeAll>
     a0e:	81 11       	cpse	r24, r1
     a10:	90 cf       	rjmp	.-224    	; 0x932 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
     a12:	0e 94 37 02 	call	0x46e	; 0x46e <vPortYield>
     a16:	8d cf       	rjmp	.-230    	; 0x932 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     a18:	c8 01       	movw	r24, r16
     a1a:	0e 94 49 03 	call	0x692	; 0x692 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     a1e:	0e 94 06 09 	call	0x120c	; 0x120c <xTaskResumeAll>
     a22:	87 cf       	rjmp	.-242    	; 0x932 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     a24:	c8 01       	movw	r24, r16
     a26:	0e 94 49 03 	call	0x692	; 0x692 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     a2a:	0e 94 06 09 	call	0x120c	; 0x120c <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     a2e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     a30:	0f 90       	pop	r0
     a32:	0f 90       	pop	r0
     a34:	0f 90       	pop	r0
     a36:	0f 90       	pop	r0
     a38:	0f 90       	pop	r0
     a3a:	df 91       	pop	r29
     a3c:	cf 91       	pop	r28
     a3e:	1f 91       	pop	r17
     a40:	0f 91       	pop	r16
     a42:	ff 90       	pop	r15
     a44:	ef 90       	pop	r14
     a46:	df 90       	pop	r13
     a48:	cf 90       	pop	r12
     a4a:	bf 90       	pop	r11
     a4c:	af 90       	pop	r10
     a4e:	9f 90       	pop	r9
     a50:	08 95       	ret

00000a52 <TaskStartCode>:
			}
		}

		
	return key;
}
     a52:	1f 93       	push	r17
     a54:	cf 93       	push	r28
     a56:	df 93       	push	r29
     a58:	13 e0       	ldi	r17, 0x03	; 3
     a5a:	2e c0       	rjmp	.+92     	; 0xab8 <TaskStartCode+0x66>
     a5c:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <lcd_clrScreen>
     a60:	ae 01       	movw	r20, r28
     a62:	60 e0       	ldi	r22, 0x00	; 0
     a64:	70 e0       	ldi	r23, 0x00	; 0
     a66:	82 e6       	ldi	r24, 0x62	; 98
     a68:	90 e0       	ldi	r25, 0x00	; 0
     a6a:	0e 94 ef 00 	call	0x1de	; 0x1de <lcd_disp_string_xy>
     a6e:	2f e7       	ldi	r18, 0x7F	; 127
     a70:	88 e3       	ldi	r24, 0x38	; 56
     a72:	91 e0       	ldi	r25, 0x01	; 1
     a74:	21 50       	subi	r18, 0x01	; 1
     a76:	80 40       	sbci	r24, 0x00	; 0
     a78:	90 40       	sbci	r25, 0x00	; 0
     a7a:	e1 f7       	brne	.-8      	; 0xa74 <TaskStartCode+0x22>
     a7c:	00 c0       	rjmp	.+0      	; 0xa7e <TaskStartCode+0x2c>
     a7e:	00 00       	nop
     a80:	21 97       	sbiw	r28, 0x01	; 1
     a82:	60 f7       	brcc	.-40     	; 0xa5c <TaskStartCode+0xa>
     a84:	c0 e0       	ldi	r28, 0x00	; 0
     a86:	d0 e0       	ldi	r29, 0x00	; 0
     a88:	ae 01       	movw	r20, r28
     a8a:	60 e0       	ldi	r22, 0x00	; 0
     a8c:	70 e0       	ldi	r23, 0x00	; 0
     a8e:	82 e6       	ldi	r24, 0x62	; 98
     a90:	90 e0       	ldi	r25, 0x00	; 0
     a92:	0e 94 ef 00 	call	0x1de	; 0x1de <lcd_disp_string_xy>
     a96:	8f e7       	ldi	r24, 0x7F	; 127
     a98:	98 e3       	ldi	r25, 0x38	; 56
     a9a:	21 e0       	ldi	r18, 0x01	; 1
     a9c:	81 50       	subi	r24, 0x01	; 1
     a9e:	90 40       	sbci	r25, 0x00	; 0
     aa0:	20 40       	sbci	r18, 0x00	; 0
     aa2:	e1 f7       	brne	.-8      	; 0xa9c <TaskStartCode+0x4a>
     aa4:	00 c0       	rjmp	.+0      	; 0xaa6 <TaskStartCode+0x54>
     aa6:	00 00       	nop
     aa8:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <lcd_clrScreen>
     aac:	21 96       	adiw	r28, 0x01	; 1
     aae:	ca 30       	cpi	r28, 0x0A	; 10
     ab0:	d1 05       	cpc	r29, r1
     ab2:	51 f7       	brne	.-44     	; 0xa88 <TaskStartCode+0x36>
     ab4:	11 50       	subi	r17, 0x01	; 1
     ab6:	a1 f0       	breq	.+40     	; 0xae0 <TaskStartCode+0x8e>
     ab8:	49 e0       	ldi	r20, 0x09	; 9
     aba:	50 e0       	ldi	r21, 0x00	; 0
     abc:	60 e0       	ldi	r22, 0x00	; 0
     abe:	70 e0       	ldi	r23, 0x00	; 0
     ac0:	82 e6       	ldi	r24, 0x62	; 98
     ac2:	90 e0       	ldi	r25, 0x00	; 0
     ac4:	0e 94 ef 00 	call	0x1de	; 0x1de <lcd_disp_string_xy>
     ac8:	8f e7       	ldi	r24, 0x7F	; 127
     aca:	98 e3       	ldi	r25, 0x38	; 56
     acc:	21 e0       	ldi	r18, 0x01	; 1
     ace:	81 50       	subi	r24, 0x01	; 1
     ad0:	90 40       	sbci	r25, 0x00	; 0
     ad2:	20 40       	sbci	r18, 0x00	; 0
     ad4:	e1 f7       	brne	.-8      	; 0xace <TaskStartCode+0x7c>
     ad6:	00 c0       	rjmp	.+0      	; 0xad8 <TaskStartCode+0x86>
     ad8:	00 00       	nop
     ada:	c8 e0       	ldi	r28, 0x08	; 8
     adc:	d0 e0       	ldi	r29, 0x00	; 0
     ade:	be cf       	rjmp	.-132    	; 0xa5c <TaskStartCode+0xa>
     ae0:	20 e0       	ldi	r18, 0x00	; 0
     ae2:	40 e0       	ldi	r20, 0x00	; 0
     ae4:	50 e0       	ldi	r21, 0x00	; 0
     ae6:	60 e0       	ldi	r22, 0x00	; 0
     ae8:	70 e0       	ldi	r23, 0x00	; 0
     aea:	80 91 4d 03 	lds	r24, 0x034D	; 0x80034d <sema>
     aee:	90 91 4e 03 	lds	r25, 0x034E	; 0x80034e <sema+0x1>
     af2:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <xQueueGenericSend>
     af6:	80 e0       	ldi	r24, 0x00	; 0
     af8:	90 e0       	ldi	r25, 0x00	; 0
     afa:	0e 94 c8 07 	call	0xf90	; 0xf90 <vTaskDelete>
     afe:	df 91       	pop	r29
     b00:	cf 91       	pop	r28
     b02:	1f 91       	pop	r17
     b04:	08 95       	ret

00000b06 <TaskCalculatorCode>:
     b06:	20 e0       	ldi	r18, 0x00	; 0
     b08:	4f ef       	ldi	r20, 0xFF	; 255
     b0a:	5f ef       	ldi	r21, 0xFF	; 255
     b0c:	60 e0       	ldi	r22, 0x00	; 0
     b0e:	70 e0       	ldi	r23, 0x00	; 0
     b10:	80 91 4d 03 	lds	r24, 0x034D	; 0x80034d <sema>
     b14:	90 91 4e 03 	lds	r25, 0x034E	; 0x80034e <sema+0x1>
     b18:	0e 94 7d 04 	call	0x8fa	; 0x8fa <xQueueGenericReceive>
     b1c:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <lcd_clrScreen>
     b20:	41 e0       	ldi	r20, 0x01	; 1
     b22:	50 e0       	ldi	r21, 0x00	; 0
     b24:	60 e0       	ldi	r22, 0x00	; 0
     b26:	70 e0       	ldi	r23, 0x00	; 0
     b28:	8a e6       	ldi	r24, 0x6A	; 106
     b2a:	90 e0       	ldi	r25, 0x00	; 0
     b2c:	0e 94 ef 00 	call	0x1de	; 0x1de <lcd_disp_string_xy>
     b30:	2f ef       	ldi	r18, 0xFF	; 255
     b32:	84 e3       	ldi	r24, 0x34	; 52
     b34:	9c e0       	ldi	r25, 0x0C	; 12
     b36:	21 50       	subi	r18, 0x01	; 1
     b38:	80 40       	sbci	r24, 0x00	; 0
     b3a:	90 40       	sbci	r25, 0x00	; 0
     b3c:	e1 f7       	brne	.-8      	; 0xb36 <TaskCalculatorCode+0x30>
     b3e:	00 c0       	rjmp	.+0      	; 0xb40 <TaskCalculatorCode+0x3a>
     b40:	00 00       	nop
     b42:	80 e0       	ldi	r24, 0x00	; 0
     b44:	90 e0       	ldi	r25, 0x00	; 0
     b46:	0e 94 c8 07 	call	0xf90	; 0xf90 <vTaskDelete>
     b4a:	08 95       	ret

00000b4c <main>:
     b4c:	af 92       	push	r10
     b4e:	bf 92       	push	r11
     b50:	cf 92       	push	r12
     b52:	df 92       	push	r13
     b54:	ef 92       	push	r14
     b56:	ff 92       	push	r15
     b58:	0f 93       	push	r16
     b5a:	0e 94 99 00 	call	0x132	; 0x132 <lcd_init>
     b5e:	8f ef       	ldi	r24, 0xFF	; 255
     b60:	8a bb       	out	0x1a, r24	; 26
     b62:	8f e0       	ldi	r24, 0x0F	; 15
     b64:	81 bb       	out	0x11, r24	; 17
     b66:	82 b3       	in	r24, 0x12	; 18
     b68:	80 6f       	ori	r24, 0xF0	; 240
     b6a:	82 bb       	out	0x12, r24	; 18
     b6c:	60 e0       	ldi	r22, 0x00	; 0
     b6e:	81 e0       	ldi	r24, 0x01	; 1
     b70:	0e 94 93 03 	call	0x726	; 0x726 <xQueueCreate>
     b74:	90 93 4e 03 	sts	0x034E, r25	; 0x80034e <sema+0x1>
     b78:	80 93 4d 03 	sts	0x034D, r24	; 0x80034d <sema>
     b7c:	00 97       	sbiw	r24, 0x00	; 0
     b7e:	39 f0       	breq	.+14     	; 0xb8e <main+0x42>
     b80:	20 e0       	ldi	r18, 0x00	; 0
     b82:	40 e0       	ldi	r20, 0x00	; 0
     b84:	50 e0       	ldi	r21, 0x00	; 0
     b86:	60 e0       	ldi	r22, 0x00	; 0
     b88:	70 e0       	ldi	r23, 0x00	; 0
     b8a:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <xQueueGenericSend>
     b8e:	20 e0       	ldi	r18, 0x00	; 0
     b90:	4f ef       	ldi	r20, 0xFF	; 255
     b92:	5f ef       	ldi	r21, 0xFF	; 255
     b94:	60 e0       	ldi	r22, 0x00	; 0
     b96:	70 e0       	ldi	r23, 0x00	; 0
     b98:	80 91 4d 03 	lds	r24, 0x034D	; 0x80034d <sema>
     b9c:	90 91 4e 03 	lds	r25, 0x034E	; 0x80034e <sema+0x1>
     ba0:	0e 94 7d 04 	call	0x8fa	; 0x8fa <xQueueGenericReceive>
     ba4:	a1 2c       	mov	r10, r1
     ba6:	b1 2c       	mov	r11, r1
     ba8:	c1 2c       	mov	r12, r1
     baa:	d1 2c       	mov	r13, r1
     bac:	e1 2c       	mov	r14, r1
     bae:	f1 2c       	mov	r15, r1
     bb0:	05 e0       	ldi	r16, 0x05	; 5
     bb2:	20 e0       	ldi	r18, 0x00	; 0
     bb4:	30 e0       	ldi	r19, 0x00	; 0
     bb6:	45 e5       	ldi	r20, 0x55	; 85
     bb8:	50 e0       	ldi	r21, 0x00	; 0
     bba:	60 e0       	ldi	r22, 0x00	; 0
     bbc:	70 e0       	ldi	r23, 0x00	; 0
     bbe:	89 e2       	ldi	r24, 0x29	; 41
     bc0:	95 e0       	ldi	r25, 0x05	; 5
     bc2:	0e 94 bf 06 	call	0xd7e	; 0xd7e <xTaskGenericCreate>
     bc6:	01 e0       	ldi	r16, 0x01	; 1
     bc8:	20 e0       	ldi	r18, 0x00	; 0
     bca:	30 e0       	ldi	r19, 0x00	; 0
     bcc:	45 e5       	ldi	r20, 0x55	; 85
     bce:	50 e0       	ldi	r21, 0x00	; 0
     bd0:	60 e0       	ldi	r22, 0x00	; 0
     bd2:	70 e0       	ldi	r23, 0x00	; 0
     bd4:	87 e1       	ldi	r24, 0x17	; 23
     bd6:	96 e0       	ldi	r25, 0x06	; 6
     bd8:	0e 94 bf 06 	call	0xd7e	; 0xd7e <xTaskGenericCreate>
     bdc:	04 e0       	ldi	r16, 0x04	; 4
     bde:	20 e0       	ldi	r18, 0x00	; 0
     be0:	30 e0       	ldi	r19, 0x00	; 0
     be2:	45 e5       	ldi	r20, 0x55	; 85
     be4:	50 e0       	ldi	r21, 0x00	; 0
     be6:	60 e0       	ldi	r22, 0x00	; 0
     be8:	70 e0       	ldi	r23, 0x00	; 0
     bea:	83 e8       	ldi	r24, 0x83	; 131
     bec:	95 e0       	ldi	r25, 0x05	; 5
     bee:	0e 94 bf 06 	call	0xd7e	; 0xd7e <xTaskGenericCreate>
     bf2:	0e 94 11 08 	call	0x1022	; 0x1022 <vTaskStartScheduler>
     bf6:	80 e0       	ldi	r24, 0x00	; 0
     bf8:	90 e0       	ldi	r25, 0x00	; 0
     bfa:	0f 91       	pop	r16
     bfc:	ff 90       	pop	r15
     bfe:	ef 90       	pop	r14
     c00:	df 90       	pop	r13
     c02:	cf 90       	pop	r12
     c04:	bf 90       	pop	r11
     c06:	af 90       	pop	r10
     c08:	08 95       	ret

00000c0a <vApplicationIdleHook>:
     c0a:	8b b3       	in	r24, 0x1b	; 27
     c0c:	80 95       	com	r24
     c0e:	8b bb       	out	0x1b, r24	; 27
     c10:	2f ef       	ldi	r18, 0xFF	; 255
     c12:	84 e3       	ldi	r24, 0x34	; 52
     c14:	9c e0       	ldi	r25, 0x0C	; 12
     c16:	21 50       	subi	r18, 0x01	; 1
     c18:	80 40       	sbci	r24, 0x00	; 0
     c1a:	90 40       	sbci	r25, 0x00	; 0
     c1c:	e1 f7       	brne	.-8      	; 0xc16 <vApplicationIdleHook+0xc>
     c1e:	00 c0       	rjmp	.+0      	; 0xc20 <vApplicationIdleHook+0x16>
     c20:	00 00       	nop
     c22:	08 95       	ret

00000c24 <PWM_set>:


void PWM_set(){                                 // PWM setup function

    // initialize timer0 in PWM mode
    TCCR0 |= (1<<WGM00)|(1<<COM01)|(1<<WGM01)|(1<<CS00);
     c24:	83 b7       	in	r24, 0x33	; 51
     c26:	89 66       	ori	r24, 0x69	; 105
     c28:	83 bf       	out	0x33, r24	; 51
    
    // make sure to make OC0 pin (pin PB3 for atmega32) as output pin
    DDRB |= (1<<PB3);
     c2a:	bb 9a       	sbi	0x17, 3	; 23
     c2c:	08 95       	ret

00000c2e <TaskPatternCode>:
}

/*Task 2 Code*/

 void TaskPatternCode(void*pvParamter)
{
     c2e:	cf 93       	push	r28
     c30:	ce e0       	ldi	r28, 0x0E	; 14
			unsigned char duty;

		for(char m=0;m<=13;m++){
			lcd_disp_string_xy("press any key" ,0 ,1);
     c32:	41 e0       	ldi	r20, 0x01	; 1
     c34:	50 e0       	ldi	r21, 0x00	; 0
     c36:	60 e0       	ldi	r22, 0x00	; 0
     c38:	70 e0       	ldi	r23, 0x00	; 0
     c3a:	8f e6       	ldi	r24, 0x6F	; 111
     c3c:	90 e0       	ldi	r25, 0x00	; 0
     c3e:	0e 94 ef 00 	call	0x1de	; 0x1de <lcd_disp_string_xy>
			lcd_disp_string_xy("to continue " ,1 ,2);
     c42:	42 e0       	ldi	r20, 0x02	; 2
     c44:	50 e0       	ldi	r21, 0x00	; 0
     c46:	61 e0       	ldi	r22, 0x01	; 1
     c48:	70 e0       	ldi	r23, 0x00	; 0
     c4a:	8d e7       	ldi	r24, 0x7D	; 125
     c4c:	90 e0       	ldi	r25, 0x00	; 0
     c4e:	0e 94 ef 00 	call	0x1de	; 0x1de <lcd_disp_string_xy>
     c52:	2f ef       	ldi	r18, 0xFF	; 255
     c54:	84 e3       	ldi	r24, 0x34	; 52
     c56:	9c e0       	ldi	r25, 0x0C	; 12
     c58:	21 50       	subi	r18, 0x01	; 1
     c5a:	80 40       	sbci	r24, 0x00	; 0
     c5c:	90 40       	sbci	r25, 0x00	; 0
     c5e:	e1 f7       	brne	.-8      	; 0xc58 <TaskPatternCode+0x2a>
     c60:	00 c0       	rjmp	.+0      	; 0xc62 <TaskPatternCode+0x34>
     c62:	00 00       	nop
			_delay_ms(500);
			lcd_clrScreen();
     c64:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <lcd_clrScreen>
     c68:	2f e7       	ldi	r18, 0x7F	; 127
     c6a:	8a e1       	ldi	r24, 0x1A	; 26
     c6c:	96 e0       	ldi	r25, 0x06	; 6
     c6e:	21 50       	subi	r18, 0x01	; 1
     c70:	80 40       	sbci	r24, 0x00	; 0
     c72:	90 40       	sbci	r25, 0x00	; 0
     c74:	e1 f7       	brne	.-8      	; 0xc6e <TaskPatternCode+0x40>
     c76:	00 c0       	rjmp	.+0      	; 0xc78 <TaskPatternCode+0x4a>
     c78:	00 00       	nop
     c7a:	c1 50       	subi	r28, 0x01	; 1

 void TaskPatternCode(void*pvParamter)
{
			unsigned char duty;

		for(char m=0;m<=13;m++){
     c7c:	d1 f6       	brne	.-76     	; 0xc32 <TaskPatternCode+0x4>
			_delay_ms(500);
			lcd_clrScreen();
			_delay_ms(250);
		}

		PWM_set();         //call PWM setup function
     c7e:	0e 94 12 06 	call	0xc24	; 0xc24 <PWM_set>
     c82:	2f ef       	ldi	r18, 0xFF	; 255
     c84:	30 e0       	ldi	r19, 0x00	; 0

		for(duty=1; duty<=10; duty++)   // 0 to max duty cycle

		{

			OCR0=duty*255/10;     //slowly increase the LED brightness
     c86:	ea e0       	ldi	r30, 0x0A	; 10
     c88:	f0 e0       	ldi	r31, 0x00	; 0
     c8a:	c9 01       	movw	r24, r18
     c8c:	bf 01       	movw	r22, r30
     c8e:	0e 94 d2 0a 	call	0x15a4	; 0x15a4 <__divmodhi4>
     c92:	6c bf       	out	0x3c, r22	; 60
     c94:	8f e4       	ldi	r24, 0x4F	; 79
     c96:	93 ec       	ldi	r25, 0xC3	; 195
     c98:	01 97       	sbiw	r24, 0x01	; 1
     c9a:	f1 f7       	brne	.-4      	; 0xc98 <TaskPatternCode+0x6a>
     c9c:	00 c0       	rjmp	.+0      	; 0xc9e <TaskPatternCode+0x70>
     c9e:	00 00       	nop
     ca0:	21 50       	subi	r18, 0x01	; 1
     ca2:	3f 4f       	sbci	r19, 0xFF	; 255
			_delay_ms(250);
		}

		PWM_set();         //call PWM setup function

		for(duty=1; duty<=10; duty++)   // 0 to max duty cycle
     ca4:	25 3f       	cpi	r18, 0xF5	; 245
     ca6:	9a e0       	ldi	r25, 0x0A	; 10
     ca8:	39 07       	cpc	r19, r25
     caa:	79 f7       	brne	.-34     	; 0xc8a <TaskPatternCode+0x5c>

			_delay_ms(25);

		}
	
	    TCCR0 &= (0<<WGM00)|(0<<COM01)|(0<<WGM01)|(0<<CS00);
     cac:	83 b7       	in	r24, 0x33	; 51
     cae:	13 be       	out	0x33, r1	; 51

		PORTB |=(1<<3);
     cb0:	c3 9a       	sbi	0x18, 3	; 24
     cb2:	2f e7       	ldi	r18, 0x7F	; 127
     cb4:	8a e1       	ldi	r24, 0x1A	; 26
     cb6:	96 e0       	ldi	r25, 0x06	; 6
     cb8:	21 50       	subi	r18, 0x01	; 1
     cba:	80 40       	sbci	r24, 0x00	; 0
     cbc:	90 40       	sbci	r25, 0x00	; 0
     cbe:	e1 f7       	brne	.-8      	; 0xcb8 <TaskPatternCode+0x8a>
     cc0:	00 c0       	rjmp	.+0      	; 0xcc2 <TaskPatternCode+0x94>
     cc2:	00 00       	nop
 		_delay_ms(250);

		PWM_set();         //call PWM setup function
     cc4:	0e 94 12 06 	call	0xc24	; 0xc24 <PWM_set>
     cc8:	26 ef       	ldi	r18, 0xF6	; 246
     cca:	39 e0       	ldi	r19, 0x09	; 9

	for(duty=10; duty>0; duty--)   // max to 0 duty cycle

		{

			OCR0=duty*255/10;     //slowly decrease the LED brightness
     ccc:	ea e0       	ldi	r30, 0x0A	; 10
     cce:	f0 e0       	ldi	r31, 0x00	; 0
     cd0:	c9 01       	movw	r24, r18
     cd2:	bf 01       	movw	r22, r30
     cd4:	0e 94 d2 0a 	call	0x15a4	; 0x15a4 <__divmodhi4>
     cd8:	6c bf       	out	0x3c, r22	; 60
     cda:	8f e4       	ldi	r24, 0x4F	; 79
     cdc:	93 ec       	ldi	r25, 0xC3	; 195
     cde:	01 97       	sbiw	r24, 0x01	; 1
     ce0:	f1 f7       	brne	.-4      	; 0xcde <TaskPatternCode+0xb0>
     ce2:	00 c0       	rjmp	.+0      	; 0xce4 <TaskPatternCode+0xb6>
     ce4:	00 00       	nop
     ce6:	2f 5f       	subi	r18, 0xFF	; 255
     ce8:	31 09       	sbc	r19, r1
 		_delay_ms(250);

		PWM_set();         //call PWM setup function


	for(duty=10; duty>0; duty--)   // max to 0 duty cycle
     cea:	91 f7       	brne	.-28     	; 0xcd0 <TaskPatternCode+0xa2>
			OCR0=duty*255/10;     //slowly decrease the LED brightness

			_delay_ms(25);

		}
    TCCR0 &= (0<<WGM00)|(0<<COM01)|(0<<WGM01)|(0<<CS00);
     cec:	83 b7       	in	r24, 0x33	; 51
     cee:	13 be       	out	0x33, r1	; 51
	PORTB &=~(1<<3);
     cf0:	c3 98       	cbi	0x18, 3	; 24
     cf2:	9f e7       	ldi	r25, 0x7F	; 127
     cf4:	2a e1       	ldi	r18, 0x1A	; 26
     cf6:	86 e0       	ldi	r24, 0x06	; 6
     cf8:	91 50       	subi	r25, 0x01	; 1
     cfa:	20 40       	sbci	r18, 0x00	; 0
     cfc:	80 40       	sbci	r24, 0x00	; 0
     cfe:	e1 f7       	brne	.-8      	; 0xcf8 <TaskPatternCode+0xca>
     d00:	00 c0       	rjmp	.+0      	; 0xd02 <TaskPatternCode+0xd4>
     d02:	00 00       	nop
	_delay_ms(250);


vTaskDelete(NULL);
     d04:	80 e0       	ldi	r24, 0x00	; 0
     d06:	90 e0       	ldi	r25, 0x00	; 0
     d08:	0e 94 c8 07 	call	0xf90	; 0xf90 <vTaskDelete>

}
     d0c:	cf 91       	pop	r28
     d0e:	08 95       	ret

00000d10 <prvAddCurrentTaskToDelayedList>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
     d10:	cf 93       	push	r28
     d12:	df 93       	push	r29
     d14:	ec 01       	movw	r28, r24
     d16:	e0 91 4b 03 	lds	r30, 0x034B	; 0x80034b <pxCurrentTCB>
     d1a:	f0 91 4c 03 	lds	r31, 0x034C	; 0x80034c <pxCurrentTCB+0x1>
     d1e:	93 83       	std	Z+3, r25	; 0x03
     d20:	82 83       	std	Z+2, r24	; 0x02
     d22:	80 91 f2 02 	lds	r24, 0x02F2	; 0x8002f2 <xTickCount>
     d26:	90 91 f3 02 	lds	r25, 0x02F3	; 0x8002f3 <xTickCount+0x1>
     d2a:	c8 17       	cp	r28, r24
     d2c:	d9 07       	cpc	r29, r25
     d2e:	68 f4       	brcc	.+26     	; 0xd4a <prvAddCurrentTaskToDelayedList+0x3a>
     d30:	60 91 4b 03 	lds	r22, 0x034B	; 0x80034b <pxCurrentTCB>
     d34:	70 91 4c 03 	lds	r23, 0x034C	; 0x80034c <pxCurrentTCB+0x1>
     d38:	80 91 08 03 	lds	r24, 0x0308	; 0x800308 <pxOverflowDelayedTaskList>
     d3c:	90 91 09 03 	lds	r25, 0x0309	; 0x800309 <pxOverflowDelayedTaskList+0x1>
     d40:	6e 5f       	subi	r22, 0xFE	; 254
     d42:	7f 4f       	sbci	r23, 0xFF	; 255
     d44:	0e 94 35 01 	call	0x26a	; 0x26a <vListInsert>
     d48:	17 c0       	rjmp	.+46     	; 0xd78 <prvAddCurrentTaskToDelayedList+0x68>
     d4a:	60 91 4b 03 	lds	r22, 0x034B	; 0x80034b <pxCurrentTCB>
     d4e:	70 91 4c 03 	lds	r23, 0x034C	; 0x80034c <pxCurrentTCB+0x1>
     d52:	80 91 0a 03 	lds	r24, 0x030A	; 0x80030a <pxDelayedTaskList>
     d56:	90 91 0b 03 	lds	r25, 0x030B	; 0x80030b <pxDelayedTaskList+0x1>
     d5a:	6e 5f       	subi	r22, 0xFE	; 254
     d5c:	7f 4f       	sbci	r23, 0xFF	; 255
     d5e:	0e 94 35 01 	call	0x26a	; 0x26a <vListInsert>
     d62:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
     d66:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
     d6a:	c8 17       	cp	r28, r24
     d6c:	d9 07       	cpc	r29, r25
     d6e:	20 f4       	brcc	.+8      	; 0xd78 <prvAddCurrentTaskToDelayedList+0x68>
     d70:	d0 93 61 00 	sts	0x0061, r29	; 0x800061 <__data_start+0x1>
     d74:	c0 93 60 00 	sts	0x0060, r28	; 0x800060 <__data_start>
     d78:	df 91       	pop	r29
     d7a:	cf 91       	pop	r28
     d7c:	08 95       	ret

00000d7e <xTaskGenericCreate>:
     d7e:	4f 92       	push	r4
     d80:	5f 92       	push	r5
     d82:	6f 92       	push	r6
     d84:	7f 92       	push	r7
     d86:	8f 92       	push	r8
     d88:	9f 92       	push	r9
     d8a:	af 92       	push	r10
     d8c:	bf 92       	push	r11
     d8e:	cf 92       	push	r12
     d90:	df 92       	push	r13
     d92:	ef 92       	push	r14
     d94:	ff 92       	push	r15
     d96:	0f 93       	push	r16
     d98:	1f 93       	push	r17
     d9a:	cf 93       	push	r28
     d9c:	df 93       	push	r29
     d9e:	5c 01       	movw	r10, r24
     da0:	4b 01       	movw	r8, r22
     da2:	ea 01       	movw	r28, r20
     da4:	29 01       	movw	r4, r18
     da6:	81 e2       	ldi	r24, 0x21	; 33
     da8:	90 e0       	ldi	r25, 0x00	; 0
     daa:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     dae:	3c 01       	movw	r6, r24
     db0:	00 97       	sbiw	r24, 0x00	; 0
     db2:	09 f4       	brne	.+2      	; 0xdb6 <xTaskGenericCreate+0x38>
     db4:	db c0       	rjmp	.+438    	; 0xf6c <xTaskGenericCreate+0x1ee>
     db6:	c1 14       	cp	r12, r1
     db8:	d1 04       	cpc	r13, r1
     dba:	09 f0       	breq	.+2      	; 0xdbe <xTaskGenericCreate+0x40>
     dbc:	d2 c0       	rjmp	.+420    	; 0xf62 <xTaskGenericCreate+0x1e4>
     dbe:	ce 01       	movw	r24, r28
     dc0:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     dc4:	f3 01       	movw	r30, r6
     dc6:	90 8f       	std	Z+24, r25	; 0x18
     dc8:	87 8b       	std	Z+23, r24	; 0x17
     dca:	00 97       	sbiw	r24, 0x00	; 0
     dcc:	21 f4       	brne	.+8      	; 0xdd6 <xTaskGenericCreate+0x58>
     dce:	c3 01       	movw	r24, r6
     dd0:	0e 94 6f 00 	call	0xde	; 0xde <vPortFree>
     dd4:	cb c0       	rjmp	.+406    	; 0xf6c <xTaskGenericCreate+0x1ee>
     dd6:	ae 01       	movw	r20, r28
     dd8:	65 ea       	ldi	r22, 0xA5	; 165
     dda:	70 e0       	ldi	r23, 0x00	; 0
     ddc:	0e 94 03 0b 	call	0x1606	; 0x1606 <memset>
     de0:	21 97       	sbiw	r28, 0x01	; 1
     de2:	f3 01       	movw	r30, r6
     de4:	87 89       	ldd	r24, Z+23	; 0x17
     de6:	90 8d       	ldd	r25, Z+24	; 0x18
     de8:	c8 0f       	add	r28, r24
     dea:	d9 1f       	adc	r29, r25
     dec:	48 e0       	ldi	r20, 0x08	; 8
     dee:	50 e0       	ldi	r21, 0x00	; 0
     df0:	b4 01       	movw	r22, r8
     df2:	c3 01       	movw	r24, r6
     df4:	49 96       	adiw	r24, 0x19	; 25
     df6:	0e 94 0a 0b 	call	0x1614	; 0x1614 <strncpy>
     dfa:	f3 01       	movw	r30, r6
     dfc:	10 a2       	std	Z+32, r1	; 0x20
     dfe:	10 2f       	mov	r17, r16
     e00:	05 30       	cpi	r16, 0x05	; 5
     e02:	08 f0       	brcs	.+2      	; 0xe06 <xTaskGenericCreate+0x88>
     e04:	14 e0       	ldi	r17, 0x04	; 4
     e06:	f3 01       	movw	r30, r6
     e08:	16 8b       	std	Z+22, r17	; 0x16
     e0a:	63 01       	movw	r12, r6
     e0c:	f2 e0       	ldi	r31, 0x02	; 2
     e0e:	cf 0e       	add	r12, r31
     e10:	d1 1c       	adc	r13, r1
     e12:	c6 01       	movw	r24, r12
     e14:	0e 94 0a 01 	call	0x214	; 0x214 <vListInitialiseItem>
     e18:	c3 01       	movw	r24, r6
     e1a:	0c 96       	adiw	r24, 0x0c	; 12
     e1c:	0e 94 0a 01 	call	0x214	; 0x214 <vListInitialiseItem>
     e20:	f3 01       	movw	r30, r6
     e22:	71 86       	std	Z+9, r7	; 0x09
     e24:	60 86       	std	Z+8, r6	; 0x08
     e26:	85 e0       	ldi	r24, 0x05	; 5
     e28:	90 e0       	ldi	r25, 0x00	; 0
     e2a:	81 1b       	sub	r24, r17
     e2c:	91 09       	sbc	r25, r1
     e2e:	95 87       	std	Z+13, r25	; 0x0d
     e30:	84 87       	std	Z+12, r24	; 0x0c
     e32:	73 8a       	std	Z+19, r7	; 0x13
     e34:	62 8a       	std	Z+18, r6	; 0x12
     e36:	a2 01       	movw	r20, r4
     e38:	b5 01       	movw	r22, r10
     e3a:	ce 01       	movw	r24, r28
     e3c:	0e 94 96 01 	call	0x32c	; 0x32c <pxPortInitialiseStack>
     e40:	f3 01       	movw	r30, r6
     e42:	91 83       	std	Z+1, r25	; 0x01
     e44:	80 83       	st	Z, r24
     e46:	e1 14       	cp	r14, r1
     e48:	f1 04       	cpc	r15, r1
     e4a:	19 f0       	breq	.+6      	; 0xe52 <xTaskGenericCreate+0xd4>
     e4c:	f7 01       	movw	r30, r14
     e4e:	71 82       	std	Z+1, r7	; 0x01
     e50:	60 82       	st	Z, r6
     e52:	0f b6       	in	r0, 0x3f	; 63
     e54:	f8 94       	cli
     e56:	0f 92       	push	r0
     e58:	80 91 f4 02 	lds	r24, 0x02F4	; 0x8002f4 <uxCurrentNumberOfTasks>
     e5c:	8f 5f       	subi	r24, 0xFF	; 255
     e5e:	80 93 f4 02 	sts	0x02F4, r24	; 0x8002f4 <uxCurrentNumberOfTasks>
     e62:	80 91 4b 03 	lds	r24, 0x034B	; 0x80034b <pxCurrentTCB>
     e66:	90 91 4c 03 	lds	r25, 0x034C	; 0x80034c <pxCurrentTCB+0x1>
     e6a:	89 2b       	or	r24, r25
     e6c:	a1 f5       	brne	.+104    	; 0xed6 <xTaskGenericCreate+0x158>
     e6e:	70 92 4c 03 	sts	0x034C, r7	; 0x80034c <pxCurrentTCB+0x1>
     e72:	60 92 4b 03 	sts	0x034B, r6	; 0x80034b <pxCurrentTCB>
     e76:	80 91 f4 02 	lds	r24, 0x02F4	; 0x8002f4 <uxCurrentNumberOfTasks>
     e7a:	81 30       	cpi	r24, 0x01	; 1
     e7c:	d9 f5       	brne	.+118    	; 0xef4 <xTaskGenericCreate+0x176>
     e7e:	ce e1       	ldi	r28, 0x1E	; 30
     e80:	d3 e0       	ldi	r29, 0x03	; 3
     e82:	0f 2e       	mov	r0, r31
     e84:	fb e4       	ldi	r31, 0x4B	; 75
     e86:	ef 2e       	mov	r14, r31
     e88:	f3 e0       	ldi	r31, 0x03	; 3
     e8a:	ff 2e       	mov	r15, r31
     e8c:	f0 2d       	mov	r31, r0
     e8e:	ce 01       	movw	r24, r28
     e90:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <vListInitialise>
     e94:	29 96       	adiw	r28, 0x09	; 9
     e96:	ce 15       	cp	r28, r14
     e98:	df 05       	cpc	r29, r15
     e9a:	c9 f7       	brne	.-14     	; 0xe8e <xTaskGenericCreate+0x110>
     e9c:	85 e1       	ldi	r24, 0x15	; 21
     e9e:	93 e0       	ldi	r25, 0x03	; 3
     ea0:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <vListInitialise>
     ea4:	8c e0       	ldi	r24, 0x0C	; 12
     ea6:	93 e0       	ldi	r25, 0x03	; 3
     ea8:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <vListInitialise>
     eac:	8f ef       	ldi	r24, 0xFF	; 255
     eae:	92 e0       	ldi	r25, 0x02	; 2
     eb0:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <vListInitialise>
     eb4:	86 ef       	ldi	r24, 0xF6	; 246
     eb6:	92 e0       	ldi	r25, 0x02	; 2
     eb8:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <vListInitialise>
     ebc:	85 e1       	ldi	r24, 0x15	; 21
     ebe:	93 e0       	ldi	r25, 0x03	; 3
     ec0:	90 93 0b 03 	sts	0x030B, r25	; 0x80030b <pxDelayedTaskList+0x1>
     ec4:	80 93 0a 03 	sts	0x030A, r24	; 0x80030a <pxDelayedTaskList>
     ec8:	8c e0       	ldi	r24, 0x0C	; 12
     eca:	93 e0       	ldi	r25, 0x03	; 3
     ecc:	90 93 09 03 	sts	0x0309, r25	; 0x800309 <pxOverflowDelayedTaskList+0x1>
     ed0:	80 93 08 03 	sts	0x0308, r24	; 0x800308 <pxOverflowDelayedTaskList>
     ed4:	0f c0       	rjmp	.+30     	; 0xef4 <xTaskGenericCreate+0x176>
     ed6:	80 91 ef 02 	lds	r24, 0x02EF	; 0x8002ef <xSchedulerRunning>
     eda:	81 11       	cpse	r24, r1
     edc:	0b c0       	rjmp	.+22     	; 0xef4 <xTaskGenericCreate+0x176>
     ede:	e0 91 4b 03 	lds	r30, 0x034B	; 0x80034b <pxCurrentTCB>
     ee2:	f0 91 4c 03 	lds	r31, 0x034C	; 0x80034c <pxCurrentTCB+0x1>
     ee6:	86 89       	ldd	r24, Z+22	; 0x16
     ee8:	08 17       	cp	r16, r24
     eea:	20 f0       	brcs	.+8      	; 0xef4 <xTaskGenericCreate+0x176>
     eec:	70 92 4c 03 	sts	0x034C, r7	; 0x80034c <pxCurrentTCB+0x1>
     ef0:	60 92 4b 03 	sts	0x034B, r6	; 0x80034b <pxCurrentTCB>
     ef4:	f3 01       	movw	r30, r6
     ef6:	86 89       	ldd	r24, Z+22	; 0x16
     ef8:	90 91 f1 02 	lds	r25, 0x02F1	; 0x8002f1 <uxTopUsedPriority>
     efc:	98 17       	cp	r25, r24
     efe:	10 f4       	brcc	.+4      	; 0xf04 <xTaskGenericCreate+0x186>
     f00:	80 93 f1 02 	sts	0x02F1, r24	; 0x8002f1 <uxTopUsedPriority>
     f04:	90 91 ea 02 	lds	r25, 0x02EA	; 0x8002ea <uxTaskNumber>
     f08:	9f 5f       	subi	r25, 0xFF	; 255
     f0a:	90 93 ea 02 	sts	0x02EA, r25	; 0x8002ea <uxTaskNumber>
     f0e:	90 91 f0 02 	lds	r25, 0x02F0	; 0x8002f0 <uxTopReadyPriority>
     f12:	98 17       	cp	r25, r24
     f14:	10 f4       	brcc	.+4      	; 0xf1a <xTaskGenericCreate+0x19c>
     f16:	80 93 f0 02 	sts	0x02F0, r24	; 0x8002f0 <uxTopReadyPriority>
     f1a:	90 e0       	ldi	r25, 0x00	; 0
     f1c:	9c 01       	movw	r18, r24
     f1e:	22 0f       	add	r18, r18
     f20:	33 1f       	adc	r19, r19
     f22:	22 0f       	add	r18, r18
     f24:	33 1f       	adc	r19, r19
     f26:	22 0f       	add	r18, r18
     f28:	33 1f       	adc	r19, r19
     f2a:	82 0f       	add	r24, r18
     f2c:	93 1f       	adc	r25, r19
     f2e:	b6 01       	movw	r22, r12
     f30:	82 5e       	subi	r24, 0xE2	; 226
     f32:	9c 4f       	sbci	r25, 0xFC	; 252
     f34:	0e 94 0e 01 	call	0x21c	; 0x21c <vListInsertEnd>
     f38:	0f 90       	pop	r0
     f3a:	0f be       	out	0x3f, r0	; 63
     f3c:	80 91 ef 02 	lds	r24, 0x02EF	; 0x8002ef <xSchedulerRunning>
     f40:	88 23       	and	r24, r24
     f42:	59 f0       	breq	.+22     	; 0xf5a <xTaskGenericCreate+0x1dc>
     f44:	e0 91 4b 03 	lds	r30, 0x034B	; 0x80034b <pxCurrentTCB>
     f48:	f0 91 4c 03 	lds	r31, 0x034C	; 0x80034c <pxCurrentTCB+0x1>
     f4c:	86 89       	ldd	r24, Z+22	; 0x16
     f4e:	80 17       	cp	r24, r16
     f50:	30 f4       	brcc	.+12     	; 0xf5e <xTaskGenericCreate+0x1e0>
     f52:	0e 94 37 02 	call	0x46e	; 0x46e <vPortYield>
     f56:	81 e0       	ldi	r24, 0x01	; 1
     f58:	0a c0       	rjmp	.+20     	; 0xf6e <xTaskGenericCreate+0x1f0>
     f5a:	81 e0       	ldi	r24, 0x01	; 1
     f5c:	08 c0       	rjmp	.+16     	; 0xf6e <xTaskGenericCreate+0x1f0>
     f5e:	81 e0       	ldi	r24, 0x01	; 1
     f60:	06 c0       	rjmp	.+12     	; 0xf6e <xTaskGenericCreate+0x1f0>
     f62:	fc 01       	movw	r30, r24
     f64:	d0 8e       	std	Z+24, r13	; 0x18
     f66:	c7 8a       	std	Z+23, r12	; 0x17
     f68:	c6 01       	movw	r24, r12
     f6a:	35 cf       	rjmp	.-406    	; 0xdd6 <xTaskGenericCreate+0x58>
     f6c:	8f ef       	ldi	r24, 0xFF	; 255
     f6e:	df 91       	pop	r29
     f70:	cf 91       	pop	r28
     f72:	1f 91       	pop	r17
     f74:	0f 91       	pop	r16
     f76:	ff 90       	pop	r15
     f78:	ef 90       	pop	r14
     f7a:	df 90       	pop	r13
     f7c:	cf 90       	pop	r12
     f7e:	bf 90       	pop	r11
     f80:	af 90       	pop	r10
     f82:	9f 90       	pop	r9
     f84:	8f 90       	pop	r8
     f86:	7f 90       	pop	r7
     f88:	6f 90       	pop	r6
     f8a:	5f 90       	pop	r5
     f8c:	4f 90       	pop	r4
     f8e:	08 95       	ret

00000f90 <vTaskDelete>:
     f90:	ef 92       	push	r14
     f92:	ff 92       	push	r15
     f94:	0f 93       	push	r16
     f96:	1f 93       	push	r17
     f98:	cf 93       	push	r28
     f9a:	df 93       	push	r29
     f9c:	ec 01       	movw	r28, r24
     f9e:	0f b6       	in	r0, 0x3f	; 63
     fa0:	f8 94       	cli
     fa2:	0f 92       	push	r0
     fa4:	80 91 4b 03 	lds	r24, 0x034B	; 0x80034b <pxCurrentTCB>
     fa8:	90 91 4c 03 	lds	r25, 0x034C	; 0x80034c <pxCurrentTCB+0x1>
     fac:	8c 17       	cp	r24, r28
     fae:	9d 07       	cpc	r25, r29
     fb0:	11 f0       	breq	.+4      	; 0xfb6 <vTaskDelete+0x26>
     fb2:	20 97       	sbiw	r28, 0x00	; 0
     fb4:	39 f4       	brne	.+14     	; 0xfc4 <vTaskDelete+0x34>
     fb6:	c0 91 4b 03 	lds	r28, 0x034B	; 0x80034b <pxCurrentTCB>
     fba:	d0 91 4c 03 	lds	r29, 0x034C	; 0x80034c <pxCurrentTCB+0x1>
     fbe:	e1 2c       	mov	r14, r1
     fc0:	f1 2c       	mov	r15, r1
     fc2:	01 c0       	rjmp	.+2      	; 0xfc6 <vTaskDelete+0x36>
     fc4:	7e 01       	movw	r14, r28
     fc6:	8e 01       	movw	r16, r28
     fc8:	0e 5f       	subi	r16, 0xFE	; 254
     fca:	1f 4f       	sbci	r17, 0xFF	; 255
     fcc:	c8 01       	movw	r24, r16
     fce:	0e 94 70 01 	call	0x2e0	; 0x2e0 <vListRemove>
     fd2:	8c 89       	ldd	r24, Y+20	; 0x14
     fd4:	9d 89       	ldd	r25, Y+21	; 0x15
     fd6:	89 2b       	or	r24, r25
     fd8:	21 f0       	breq	.+8      	; 0xfe2 <vTaskDelete+0x52>
     fda:	ce 01       	movw	r24, r28
     fdc:	0c 96       	adiw	r24, 0x0c	; 12
     fde:	0e 94 70 01 	call	0x2e0	; 0x2e0 <vListRemove>
     fe2:	b8 01       	movw	r22, r16
     fe4:	86 ef       	ldi	r24, 0xF6	; 246
     fe6:	92 e0       	ldi	r25, 0x02	; 2
     fe8:	0e 94 0e 01 	call	0x21c	; 0x21c <vListInsertEnd>
     fec:	80 91 f5 02 	lds	r24, 0x02F5	; 0x8002f5 <uxTasksDeleted>
     ff0:	8f 5f       	subi	r24, 0xFF	; 255
     ff2:	80 93 f5 02 	sts	0x02F5, r24	; 0x8002f5 <uxTasksDeleted>
     ff6:	80 91 ea 02 	lds	r24, 0x02EA	; 0x8002ea <uxTaskNumber>
     ffa:	8f 5f       	subi	r24, 0xFF	; 255
     ffc:	80 93 ea 02 	sts	0x02EA, r24	; 0x8002ea <uxTaskNumber>
    1000:	0f 90       	pop	r0
    1002:	0f be       	out	0x3f, r0	; 63
    1004:	80 91 ef 02 	lds	r24, 0x02EF	; 0x8002ef <xSchedulerRunning>
    1008:	88 23       	and	r24, r24
    100a:	21 f0       	breq	.+8      	; 0x1014 <vTaskDelete+0x84>
    100c:	ef 28       	or	r14, r15
    100e:	11 f4       	brne	.+4      	; 0x1014 <vTaskDelete+0x84>
    1010:	0e 94 37 02 	call	0x46e	; 0x46e <vPortYield>
    1014:	df 91       	pop	r29
    1016:	cf 91       	pop	r28
    1018:	1f 91       	pop	r17
    101a:	0f 91       	pop	r16
    101c:	ff 90       	pop	r15
    101e:	ef 90       	pop	r14
    1020:	08 95       	ret

00001022 <vTaskStartScheduler>:
    1022:	af 92       	push	r10
    1024:	bf 92       	push	r11
    1026:	cf 92       	push	r12
    1028:	df 92       	push	r13
    102a:	ef 92       	push	r14
    102c:	ff 92       	push	r15
    102e:	0f 93       	push	r16
    1030:	a1 2c       	mov	r10, r1
    1032:	b1 2c       	mov	r11, r1
    1034:	c1 2c       	mov	r12, r1
    1036:	d1 2c       	mov	r13, r1
    1038:	e1 2c       	mov	r14, r1
    103a:	f1 2c       	mov	r15, r1
    103c:	00 e0       	ldi	r16, 0x00	; 0
    103e:	20 e0       	ldi	r18, 0x00	; 0
    1040:	30 e0       	ldi	r19, 0x00	; 0
    1042:	45 e5       	ldi	r20, 0x55	; 85
    1044:	50 e0       	ldi	r21, 0x00	; 0
    1046:	6a e8       	ldi	r22, 0x8A	; 138
    1048:	70 e0       	ldi	r23, 0x00	; 0
    104a:	8c e8       	ldi	r24, 0x8C	; 140
    104c:	99 e0       	ldi	r25, 0x09	; 9
    104e:	0e 94 bf 06 	call	0xd7e	; 0xd7e <xTaskGenericCreate>
    1052:	81 30       	cpi	r24, 0x01	; 1
    1054:	49 f4       	brne	.+18     	; 0x1068 <vTaskStartScheduler+0x46>
    1056:	f8 94       	cli
    1058:	80 93 ef 02 	sts	0x02EF, r24	; 0x8002ef <xSchedulerRunning>
    105c:	10 92 f3 02 	sts	0x02F3, r1	; 0x8002f3 <xTickCount+0x1>
    1060:	10 92 f2 02 	sts	0x02F2, r1	; 0x8002f2 <xTickCount>
    1064:	0e 94 02 02 	call	0x404	; 0x404 <xPortStartScheduler>
    1068:	0f 91       	pop	r16
    106a:	ff 90       	pop	r15
    106c:	ef 90       	pop	r14
    106e:	df 90       	pop	r13
    1070:	cf 90       	pop	r12
    1072:	bf 90       	pop	r11
    1074:	af 90       	pop	r10
    1076:	08 95       	ret

00001078 <vTaskSuspendAll>:
    1078:	80 91 ee 02 	lds	r24, 0x02EE	; 0x8002ee <uxSchedulerSuspended>
    107c:	8f 5f       	subi	r24, 0xFF	; 255
    107e:	80 93 ee 02 	sts	0x02EE, r24	; 0x8002ee <uxSchedulerSuspended>
    1082:	08 95       	ret

00001084 <vTaskIncrementTick>:
    1084:	0f 93       	push	r16
    1086:	1f 93       	push	r17
    1088:	cf 93       	push	r28
    108a:	df 93       	push	r29
    108c:	80 91 ee 02 	lds	r24, 0x02EE	; 0x8002ee <uxSchedulerSuspended>
    1090:	81 11       	cpse	r24, r1
    1092:	b2 c0       	rjmp	.+356    	; 0x11f8 <vTaskIncrementTick+0x174>
    1094:	80 91 f2 02 	lds	r24, 0x02F2	; 0x8002f2 <xTickCount>
    1098:	90 91 f3 02 	lds	r25, 0x02F3	; 0x8002f3 <xTickCount+0x1>
    109c:	01 96       	adiw	r24, 0x01	; 1
    109e:	90 93 f3 02 	sts	0x02F3, r25	; 0x8002f3 <xTickCount+0x1>
    10a2:	80 93 f2 02 	sts	0x02F2, r24	; 0x8002f2 <xTickCount>
    10a6:	80 91 f2 02 	lds	r24, 0x02F2	; 0x8002f2 <xTickCount>
    10aa:	90 91 f3 02 	lds	r25, 0x02F3	; 0x8002f3 <xTickCount+0x1>
    10ae:	89 2b       	or	r24, r25
    10b0:	99 f5       	brne	.+102    	; 0x1118 <vTaskIncrementTick+0x94>
    10b2:	80 91 0a 03 	lds	r24, 0x030A	; 0x80030a <pxDelayedTaskList>
    10b6:	90 91 0b 03 	lds	r25, 0x030B	; 0x80030b <pxDelayedTaskList+0x1>
    10ba:	20 91 08 03 	lds	r18, 0x0308	; 0x800308 <pxOverflowDelayedTaskList>
    10be:	30 91 09 03 	lds	r19, 0x0309	; 0x800309 <pxOverflowDelayedTaskList+0x1>
    10c2:	30 93 0b 03 	sts	0x030B, r19	; 0x80030b <pxDelayedTaskList+0x1>
    10c6:	20 93 0a 03 	sts	0x030A, r18	; 0x80030a <pxDelayedTaskList>
    10ca:	90 93 09 03 	sts	0x0309, r25	; 0x800309 <pxOverflowDelayedTaskList+0x1>
    10ce:	80 93 08 03 	sts	0x0308, r24	; 0x800308 <pxOverflowDelayedTaskList>
    10d2:	80 91 eb 02 	lds	r24, 0x02EB	; 0x8002eb <xNumOfOverflows>
    10d6:	8f 5f       	subi	r24, 0xFF	; 255
    10d8:	80 93 eb 02 	sts	0x02EB, r24	; 0x8002eb <xNumOfOverflows>
    10dc:	e0 91 0a 03 	lds	r30, 0x030A	; 0x80030a <pxDelayedTaskList>
    10e0:	f0 91 0b 03 	lds	r31, 0x030B	; 0x80030b <pxDelayedTaskList+0x1>
    10e4:	80 81       	ld	r24, Z
    10e6:	81 11       	cpse	r24, r1
    10e8:	07 c0       	rjmp	.+14     	; 0x10f8 <vTaskIncrementTick+0x74>
    10ea:	8f ef       	ldi	r24, 0xFF	; 255
    10ec:	9f ef       	ldi	r25, 0xFF	; 255
    10ee:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
    10f2:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
    10f6:	10 c0       	rjmp	.+32     	; 0x1118 <vTaskIncrementTick+0x94>
    10f8:	e0 91 0a 03 	lds	r30, 0x030A	; 0x80030a <pxDelayedTaskList>
    10fc:	f0 91 0b 03 	lds	r31, 0x030B	; 0x80030b <pxDelayedTaskList+0x1>
    1100:	05 80       	ldd	r0, Z+5	; 0x05
    1102:	f6 81       	ldd	r31, Z+6	; 0x06
    1104:	e0 2d       	mov	r30, r0
    1106:	06 80       	ldd	r0, Z+6	; 0x06
    1108:	f7 81       	ldd	r31, Z+7	; 0x07
    110a:	e0 2d       	mov	r30, r0
    110c:	82 81       	ldd	r24, Z+2	; 0x02
    110e:	93 81       	ldd	r25, Z+3	; 0x03
    1110:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
    1114:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
    1118:	20 91 f2 02 	lds	r18, 0x02F2	; 0x8002f2 <xTickCount>
    111c:	30 91 f3 02 	lds	r19, 0x02F3	; 0x8002f3 <xTickCount+0x1>
    1120:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
    1124:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
    1128:	28 17       	cp	r18, r24
    112a:	39 07       	cpc	r19, r25
    112c:	08 f4       	brcc	.+2      	; 0x1130 <vTaskIncrementTick+0xac>
    112e:	69 c0       	rjmp	.+210    	; 0x1202 <vTaskIncrementTick+0x17e>
    1130:	e0 91 0a 03 	lds	r30, 0x030A	; 0x80030a <pxDelayedTaskList>
    1134:	f0 91 0b 03 	lds	r31, 0x030B	; 0x80030b <pxDelayedTaskList+0x1>
    1138:	80 81       	ld	r24, Z
    113a:	88 23       	and	r24, r24
    113c:	99 f0       	breq	.+38     	; 0x1164 <vTaskIncrementTick+0xe0>
    113e:	e0 91 0a 03 	lds	r30, 0x030A	; 0x80030a <pxDelayedTaskList>
    1142:	f0 91 0b 03 	lds	r31, 0x030B	; 0x80030b <pxDelayedTaskList+0x1>
    1146:	05 80       	ldd	r0, Z+5	; 0x05
    1148:	f6 81       	ldd	r31, Z+6	; 0x06
    114a:	e0 2d       	mov	r30, r0
    114c:	c6 81       	ldd	r28, Z+6	; 0x06
    114e:	d7 81       	ldd	r29, Z+7	; 0x07
    1150:	8a 81       	ldd	r24, Y+2	; 0x02
    1152:	9b 81       	ldd	r25, Y+3	; 0x03
    1154:	20 91 f2 02 	lds	r18, 0x02F2	; 0x8002f2 <xTickCount>
    1158:	30 91 f3 02 	lds	r19, 0x02F3	; 0x8002f3 <xTickCount+0x1>
    115c:	28 17       	cp	r18, r24
    115e:	39 07       	cpc	r19, r25
    1160:	f8 f4       	brcc	.+62     	; 0x11a0 <vTaskIncrementTick+0x11c>
    1162:	19 c0       	rjmp	.+50     	; 0x1196 <vTaskIncrementTick+0x112>
    1164:	8f ef       	ldi	r24, 0xFF	; 255
    1166:	9f ef       	ldi	r25, 0xFF	; 255
    1168:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
    116c:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
    1170:	48 c0       	rjmp	.+144    	; 0x1202 <vTaskIncrementTick+0x17e>
    1172:	e0 91 0a 03 	lds	r30, 0x030A	; 0x80030a <pxDelayedTaskList>
    1176:	f0 91 0b 03 	lds	r31, 0x030B	; 0x80030b <pxDelayedTaskList+0x1>
    117a:	05 80       	ldd	r0, Z+5	; 0x05
    117c:	f6 81       	ldd	r31, Z+6	; 0x06
    117e:	e0 2d       	mov	r30, r0
    1180:	c6 81       	ldd	r28, Z+6	; 0x06
    1182:	d7 81       	ldd	r29, Z+7	; 0x07
    1184:	8a 81       	ldd	r24, Y+2	; 0x02
    1186:	9b 81       	ldd	r25, Y+3	; 0x03
    1188:	20 91 f2 02 	lds	r18, 0x02F2	; 0x8002f2 <xTickCount>
    118c:	30 91 f3 02 	lds	r19, 0x02F3	; 0x8002f3 <xTickCount+0x1>
    1190:	28 17       	cp	r18, r24
    1192:	39 07       	cpc	r19, r25
    1194:	28 f4       	brcc	.+10     	; 0x11a0 <vTaskIncrementTick+0x11c>
    1196:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
    119a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
    119e:	31 c0       	rjmp	.+98     	; 0x1202 <vTaskIncrementTick+0x17e>
    11a0:	8e 01       	movw	r16, r28
    11a2:	0e 5f       	subi	r16, 0xFE	; 254
    11a4:	1f 4f       	sbci	r17, 0xFF	; 255
    11a6:	c8 01       	movw	r24, r16
    11a8:	0e 94 70 01 	call	0x2e0	; 0x2e0 <vListRemove>
    11ac:	8c 89       	ldd	r24, Y+20	; 0x14
    11ae:	9d 89       	ldd	r25, Y+21	; 0x15
    11b0:	89 2b       	or	r24, r25
    11b2:	21 f0       	breq	.+8      	; 0x11bc <vTaskIncrementTick+0x138>
    11b4:	ce 01       	movw	r24, r28
    11b6:	0c 96       	adiw	r24, 0x0c	; 12
    11b8:	0e 94 70 01 	call	0x2e0	; 0x2e0 <vListRemove>
    11bc:	8e 89       	ldd	r24, Y+22	; 0x16
    11be:	90 91 f0 02 	lds	r25, 0x02F0	; 0x8002f0 <uxTopReadyPriority>
    11c2:	98 17       	cp	r25, r24
    11c4:	10 f4       	brcc	.+4      	; 0x11ca <vTaskIncrementTick+0x146>
    11c6:	80 93 f0 02 	sts	0x02F0, r24	; 0x8002f0 <uxTopReadyPriority>
    11ca:	90 e0       	ldi	r25, 0x00	; 0
    11cc:	9c 01       	movw	r18, r24
    11ce:	22 0f       	add	r18, r18
    11d0:	33 1f       	adc	r19, r19
    11d2:	22 0f       	add	r18, r18
    11d4:	33 1f       	adc	r19, r19
    11d6:	22 0f       	add	r18, r18
    11d8:	33 1f       	adc	r19, r19
    11da:	82 0f       	add	r24, r18
    11dc:	93 1f       	adc	r25, r19
    11de:	b8 01       	movw	r22, r16
    11e0:	82 5e       	subi	r24, 0xE2	; 226
    11e2:	9c 4f       	sbci	r25, 0xFC	; 252
    11e4:	0e 94 0e 01 	call	0x21c	; 0x21c <vListInsertEnd>
    11e8:	e0 91 0a 03 	lds	r30, 0x030A	; 0x80030a <pxDelayedTaskList>
    11ec:	f0 91 0b 03 	lds	r31, 0x030B	; 0x80030b <pxDelayedTaskList+0x1>
    11f0:	80 81       	ld	r24, Z
    11f2:	81 11       	cpse	r24, r1
    11f4:	be cf       	rjmp	.-132    	; 0x1172 <vTaskIncrementTick+0xee>
    11f6:	b6 cf       	rjmp	.-148    	; 0x1164 <vTaskIncrementTick+0xe0>
    11f8:	80 91 ed 02 	lds	r24, 0x02ED	; 0x8002ed <uxMissedTicks>
    11fc:	8f 5f       	subi	r24, 0xFF	; 255
    11fe:	80 93 ed 02 	sts	0x02ED, r24	; 0x8002ed <uxMissedTicks>
    1202:	df 91       	pop	r29
    1204:	cf 91       	pop	r28
    1206:	1f 91       	pop	r17
    1208:	0f 91       	pop	r16
    120a:	08 95       	ret

0000120c <xTaskResumeAll>:
    120c:	cf 92       	push	r12
    120e:	df 92       	push	r13
    1210:	ef 92       	push	r14
    1212:	ff 92       	push	r15
    1214:	0f 93       	push	r16
    1216:	1f 93       	push	r17
    1218:	cf 93       	push	r28
    121a:	df 93       	push	r29
    121c:	0f b6       	in	r0, 0x3f	; 63
    121e:	f8 94       	cli
    1220:	0f 92       	push	r0
    1222:	80 91 ee 02 	lds	r24, 0x02EE	; 0x8002ee <uxSchedulerSuspended>
    1226:	81 50       	subi	r24, 0x01	; 1
    1228:	80 93 ee 02 	sts	0x02EE, r24	; 0x8002ee <uxSchedulerSuspended>
    122c:	80 91 ee 02 	lds	r24, 0x02EE	; 0x8002ee <uxSchedulerSuspended>
    1230:	81 11       	cpse	r24, r1
    1232:	64 c0       	rjmp	.+200    	; 0x12fc <xTaskResumeAll+0xf0>
    1234:	80 91 f4 02 	lds	r24, 0x02F4	; 0x8002f4 <uxCurrentNumberOfTasks>
    1238:	81 11       	cpse	r24, r1
    123a:	32 c0       	rjmp	.+100    	; 0x12a0 <xTaskResumeAll+0x94>
    123c:	62 c0       	rjmp	.+196    	; 0x1302 <xTaskResumeAll+0xf6>
    123e:	d7 01       	movw	r26, r14
    1240:	15 96       	adiw	r26, 0x05	; 5
    1242:	ed 91       	ld	r30, X+
    1244:	fc 91       	ld	r31, X
    1246:	16 97       	sbiw	r26, 0x06	; 6
    1248:	c6 81       	ldd	r28, Z+6	; 0x06
    124a:	d7 81       	ldd	r29, Z+7	; 0x07
    124c:	ce 01       	movw	r24, r28
    124e:	0c 96       	adiw	r24, 0x0c	; 12
    1250:	0e 94 70 01 	call	0x2e0	; 0x2e0 <vListRemove>
    1254:	8e 01       	movw	r16, r28
    1256:	0e 5f       	subi	r16, 0xFE	; 254
    1258:	1f 4f       	sbci	r17, 0xFF	; 255
    125a:	c8 01       	movw	r24, r16
    125c:	0e 94 70 01 	call	0x2e0	; 0x2e0 <vListRemove>
    1260:	8e 89       	ldd	r24, Y+22	; 0x16
    1262:	90 91 f0 02 	lds	r25, 0x02F0	; 0x8002f0 <uxTopReadyPriority>
    1266:	98 17       	cp	r25, r24
    1268:	10 f4       	brcc	.+4      	; 0x126e <xTaskResumeAll+0x62>
    126a:	80 93 f0 02 	sts	0x02F0, r24	; 0x8002f0 <uxTopReadyPriority>
    126e:	90 e0       	ldi	r25, 0x00	; 0
    1270:	9c 01       	movw	r18, r24
    1272:	22 0f       	add	r18, r18
    1274:	33 1f       	adc	r19, r19
    1276:	22 0f       	add	r18, r18
    1278:	33 1f       	adc	r19, r19
    127a:	22 0f       	add	r18, r18
    127c:	33 1f       	adc	r19, r19
    127e:	82 0f       	add	r24, r18
    1280:	93 1f       	adc	r25, r19
    1282:	b8 01       	movw	r22, r16
    1284:	82 5e       	subi	r24, 0xE2	; 226
    1286:	9c 4f       	sbci	r25, 0xFC	; 252
    1288:	0e 94 0e 01 	call	0x21c	; 0x21c <vListInsertEnd>
    128c:	e0 91 4b 03 	lds	r30, 0x034B	; 0x80034b <pxCurrentTCB>
    1290:	f0 91 4c 03 	lds	r31, 0x034C	; 0x80034c <pxCurrentTCB+0x1>
    1294:	9e 89       	ldd	r25, Y+22	; 0x16
    1296:	86 89       	ldd	r24, Z+22	; 0x16
    1298:	98 17       	cp	r25, r24
    129a:	58 f0       	brcs	.+22     	; 0x12b2 <xTaskResumeAll+0xa6>
    129c:	dc 2c       	mov	r13, r12
    129e:	09 c0       	rjmp	.+18     	; 0x12b2 <xTaskResumeAll+0xa6>
    12a0:	d1 2c       	mov	r13, r1
    12a2:	0f 2e       	mov	r0, r31
    12a4:	ff ef       	ldi	r31, 0xFF	; 255
    12a6:	ef 2e       	mov	r14, r31
    12a8:	f2 e0       	ldi	r31, 0x02	; 2
    12aa:	ff 2e       	mov	r15, r31
    12ac:	f0 2d       	mov	r31, r0
    12ae:	cc 24       	eor	r12, r12
    12b0:	c3 94       	inc	r12
    12b2:	f7 01       	movw	r30, r14
    12b4:	80 81       	ld	r24, Z
    12b6:	81 11       	cpse	r24, r1
    12b8:	c2 cf       	rjmp	.-124    	; 0x123e <xTaskResumeAll+0x32>
    12ba:	80 91 ed 02 	lds	r24, 0x02ED	; 0x8002ed <uxMissedTicks>
    12be:	88 23       	and	r24, r24
    12c0:	81 f0       	breq	.+32     	; 0x12e2 <xTaskResumeAll+0xd6>
    12c2:	80 91 ed 02 	lds	r24, 0x02ED	; 0x8002ed <uxMissedTicks>
    12c6:	88 23       	and	r24, r24
    12c8:	99 f0       	breq	.+38     	; 0x12f0 <xTaskResumeAll+0xe4>
    12ca:	0e 94 42 08 	call	0x1084	; 0x1084 <vTaskIncrementTick>
    12ce:	80 91 ed 02 	lds	r24, 0x02ED	; 0x8002ed <uxMissedTicks>
    12d2:	81 50       	subi	r24, 0x01	; 1
    12d4:	80 93 ed 02 	sts	0x02ED, r24	; 0x8002ed <uxMissedTicks>
    12d8:	80 91 ed 02 	lds	r24, 0x02ED	; 0x8002ed <uxMissedTicks>
    12dc:	81 11       	cpse	r24, r1
    12de:	f5 cf       	rjmp	.-22     	; 0x12ca <xTaskResumeAll+0xbe>
    12e0:	07 c0       	rjmp	.+14     	; 0x12f0 <xTaskResumeAll+0xe4>
    12e2:	f1 e0       	ldi	r31, 0x01	; 1
    12e4:	df 16       	cp	r13, r31
    12e6:	21 f0       	breq	.+8      	; 0x12f0 <xTaskResumeAll+0xe4>
    12e8:	80 91 ec 02 	lds	r24, 0x02EC	; 0x8002ec <xMissedYield>
    12ec:	81 30       	cpi	r24, 0x01	; 1
    12ee:	41 f4       	brne	.+16     	; 0x1300 <xTaskResumeAll+0xf4>
    12f0:	10 92 ec 02 	sts	0x02EC, r1	; 0x8002ec <xMissedYield>
    12f4:	0e 94 37 02 	call	0x46e	; 0x46e <vPortYield>
    12f8:	81 e0       	ldi	r24, 0x01	; 1
    12fa:	03 c0       	rjmp	.+6      	; 0x1302 <xTaskResumeAll+0xf6>
    12fc:	80 e0       	ldi	r24, 0x00	; 0
    12fe:	01 c0       	rjmp	.+2      	; 0x1302 <xTaskResumeAll+0xf6>
    1300:	80 e0       	ldi	r24, 0x00	; 0
    1302:	0f 90       	pop	r0
    1304:	0f be       	out	0x3f, r0	; 63
    1306:	df 91       	pop	r29
    1308:	cf 91       	pop	r28
    130a:	1f 91       	pop	r17
    130c:	0f 91       	pop	r16
    130e:	ff 90       	pop	r15
    1310:	ef 90       	pop	r14
    1312:	df 90       	pop	r13
    1314:	cf 90       	pop	r12
    1316:	08 95       	ret

00001318 <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1318:	06 ef       	ldi	r16, 0xF6	; 246
    131a:	12 e0       	ldi	r17, 0x02	; 2
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    131c:	80 91 f5 02 	lds	r24, 0x02F5	; 0x8002f5 <uxTasksDeleted>
    1320:	88 23       	and	r24, r24
    1322:	49 f1       	breq	.+82     	; 0x1376 <prvIdleTask+0x5e>
		{
			vTaskSuspendAll();
    1324:	0e 94 3c 08 	call	0x1078	; 0x1078 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1328:	d8 01       	movw	r26, r16
    132a:	cc 91       	ld	r28, X
			xTaskResumeAll();
    132c:	0e 94 06 09 	call	0x120c	; 0x120c <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1330:	cc 23       	and	r28, r28
    1332:	09 f1       	breq	.+66     	; 0x1376 <prvIdleTask+0x5e>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    1334:	0f b6       	in	r0, 0x3f	; 63
    1336:	f8 94       	cli
    1338:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    133a:	d8 01       	movw	r26, r16
    133c:	15 96       	adiw	r26, 0x05	; 5
    133e:	ed 91       	ld	r30, X+
    1340:	fc 91       	ld	r31, X
    1342:	16 97       	sbiw	r26, 0x06	; 6
    1344:	c6 81       	ldd	r28, Z+6	; 0x06
    1346:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    1348:	ce 01       	movw	r24, r28
    134a:	02 96       	adiw	r24, 0x02	; 2
    134c:	0e 94 70 01 	call	0x2e0	; 0x2e0 <vListRemove>
					--uxCurrentNumberOfTasks;
    1350:	80 91 f4 02 	lds	r24, 0x02F4	; 0x8002f4 <uxCurrentNumberOfTasks>
    1354:	81 50       	subi	r24, 0x01	; 1
    1356:	80 93 f4 02 	sts	0x02F4, r24	; 0x8002f4 <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
    135a:	80 91 f5 02 	lds	r24, 0x02F5	; 0x8002f5 <uxTasksDeleted>
    135e:	81 50       	subi	r24, 0x01	; 1
    1360:	80 93 f5 02 	sts	0x02F5, r24	; 0x8002f5 <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
    1364:	0f 90       	pop	r0
    1366:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    1368:	8f 89       	ldd	r24, Y+23	; 0x17
    136a:	98 8d       	ldd	r25, Y+24	; 0x18
    136c:	0e 94 6f 00 	call	0xde	; 0xde <vPortFree>
		vPortFree( pxTCB );
    1370:	ce 01       	movw	r24, r28
    1372:	0e 94 6f 00 	call	0xde	; 0xde <vPortFree>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
    1376:	0e 94 05 06 	call	0xc0a	; 0xc0a <vApplicationIdleHook>
		}
		#endif
	}
    137a:	d0 cf       	rjmp	.-96     	; 0x131c <prvIdleTask+0x4>

0000137c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    137c:	80 91 ee 02 	lds	r24, 0x02EE	; 0x8002ee <uxSchedulerSuspended>
    1380:	81 11       	cpse	r24, r1
    1382:	13 c0       	rjmp	.+38     	; 0x13aa <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1384:	80 91 f0 02 	lds	r24, 0x02F0	; 0x8002f0 <uxTopReadyPriority>
    1388:	90 e0       	ldi	r25, 0x00	; 0
    138a:	fc 01       	movw	r30, r24
    138c:	ee 0f       	add	r30, r30
    138e:	ff 1f       	adc	r31, r31
    1390:	ee 0f       	add	r30, r30
    1392:	ff 1f       	adc	r31, r31
    1394:	ee 0f       	add	r30, r30
    1396:	ff 1f       	adc	r31, r31
    1398:	8e 0f       	add	r24, r30
    139a:	9f 1f       	adc	r25, r31
    139c:	fc 01       	movw	r30, r24
    139e:	e2 5e       	subi	r30, 0xE2	; 226
    13a0:	fc 4f       	sbci	r31, 0xFC	; 252
    13a2:	80 81       	ld	r24, Z
    13a4:	88 23       	and	r24, r24
    13a6:	29 f0       	breq	.+10     	; 0x13b2 <vTaskSwitchContext+0x36>
    13a8:	1b c0       	rjmp	.+54     	; 0x13e0 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    13aa:	81 e0       	ldi	r24, 0x01	; 1
    13ac:	80 93 ec 02 	sts	0x02EC, r24	; 0x8002ec <xMissedYield>
    13b0:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    13b2:	80 91 f0 02 	lds	r24, 0x02F0	; 0x8002f0 <uxTopReadyPriority>
    13b6:	81 50       	subi	r24, 0x01	; 1
    13b8:	80 93 f0 02 	sts	0x02F0, r24	; 0x8002f0 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    13bc:	80 91 f0 02 	lds	r24, 0x02F0	; 0x8002f0 <uxTopReadyPriority>
    13c0:	90 e0       	ldi	r25, 0x00	; 0
    13c2:	fc 01       	movw	r30, r24
    13c4:	ee 0f       	add	r30, r30
    13c6:	ff 1f       	adc	r31, r31
    13c8:	ee 0f       	add	r30, r30
    13ca:	ff 1f       	adc	r31, r31
    13cc:	ee 0f       	add	r30, r30
    13ce:	ff 1f       	adc	r31, r31
    13d0:	8e 0f       	add	r24, r30
    13d2:	9f 1f       	adc	r25, r31
    13d4:	fc 01       	movw	r30, r24
    13d6:	e2 5e       	subi	r30, 0xE2	; 226
    13d8:	fc 4f       	sbci	r31, 0xFC	; 252
    13da:	80 81       	ld	r24, Z
    13dc:	88 23       	and	r24, r24
    13de:	49 f3       	breq	.-46     	; 0x13b2 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    13e0:	80 91 f0 02 	lds	r24, 0x02F0	; 0x8002f0 <uxTopReadyPriority>
    13e4:	90 e0       	ldi	r25, 0x00	; 0
    13e6:	9c 01       	movw	r18, r24
    13e8:	22 0f       	add	r18, r18
    13ea:	33 1f       	adc	r19, r19
    13ec:	22 0f       	add	r18, r18
    13ee:	33 1f       	adc	r19, r19
    13f0:	22 0f       	add	r18, r18
    13f2:	33 1f       	adc	r19, r19
    13f4:	28 0f       	add	r18, r24
    13f6:	39 1f       	adc	r19, r25
    13f8:	d9 01       	movw	r26, r18
    13fa:	a2 5e       	subi	r26, 0xE2	; 226
    13fc:	bc 4f       	sbci	r27, 0xFC	; 252
    13fe:	11 96       	adiw	r26, 0x01	; 1
    1400:	ed 91       	ld	r30, X+
    1402:	fc 91       	ld	r31, X
    1404:	12 97       	sbiw	r26, 0x02	; 2
    1406:	02 80       	ldd	r0, Z+2	; 0x02
    1408:	f3 81       	ldd	r31, Z+3	; 0x03
    140a:	e0 2d       	mov	r30, r0
    140c:	12 96       	adiw	r26, 0x02	; 2
    140e:	fc 93       	st	X, r31
    1410:	ee 93       	st	-X, r30
    1412:	11 97       	sbiw	r26, 0x01	; 1
    1414:	2f 5d       	subi	r18, 0xDF	; 223
    1416:	3c 4f       	sbci	r19, 0xFC	; 252
    1418:	e2 17       	cp	r30, r18
    141a:	f3 07       	cpc	r31, r19
    141c:	29 f4       	brne	.+10     	; 0x1428 <vTaskSwitchContext+0xac>
    141e:	22 81       	ldd	r18, Z+2	; 0x02
    1420:	33 81       	ldd	r19, Z+3	; 0x03
    1422:	fd 01       	movw	r30, r26
    1424:	32 83       	std	Z+2, r19	; 0x02
    1426:	21 83       	std	Z+1, r18	; 0x01
    1428:	fc 01       	movw	r30, r24
    142a:	ee 0f       	add	r30, r30
    142c:	ff 1f       	adc	r31, r31
    142e:	ee 0f       	add	r30, r30
    1430:	ff 1f       	adc	r31, r31
    1432:	ee 0f       	add	r30, r30
    1434:	ff 1f       	adc	r31, r31
    1436:	8e 0f       	add	r24, r30
    1438:	9f 1f       	adc	r25, r31
    143a:	fc 01       	movw	r30, r24
    143c:	e2 5e       	subi	r30, 0xE2	; 226
    143e:	fc 4f       	sbci	r31, 0xFC	; 252
    1440:	01 80       	ldd	r0, Z+1	; 0x01
    1442:	f2 81       	ldd	r31, Z+2	; 0x02
    1444:	e0 2d       	mov	r30, r0
    1446:	86 81       	ldd	r24, Z+6	; 0x06
    1448:	97 81       	ldd	r25, Z+7	; 0x07
    144a:	90 93 4c 03 	sts	0x034C, r25	; 0x80034c <pxCurrentTCB+0x1>
    144e:	80 93 4b 03 	sts	0x034B, r24	; 0x80034b <pxCurrentTCB>
    1452:	08 95       	ret

00001454 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1454:	cf 93       	push	r28
    1456:	df 93       	push	r29
    1458:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    145a:	60 91 4b 03 	lds	r22, 0x034B	; 0x80034b <pxCurrentTCB>
    145e:	70 91 4c 03 	lds	r23, 0x034C	; 0x80034c <pxCurrentTCB+0x1>
    1462:	64 5f       	subi	r22, 0xF4	; 244
    1464:	7f 4f       	sbci	r23, 0xFF	; 255
    1466:	0e 94 35 01 	call	0x26a	; 0x26a <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    146a:	80 91 4b 03 	lds	r24, 0x034B	; 0x80034b <pxCurrentTCB>
    146e:	90 91 4c 03 	lds	r25, 0x034C	; 0x80034c <pxCurrentTCB+0x1>
    1472:	02 96       	adiw	r24, 0x02	; 2
    1474:	0e 94 70 01 	call	0x2e0	; 0x2e0 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1478:	80 91 f2 02 	lds	r24, 0x02F2	; 0x8002f2 <xTickCount>
    147c:	90 91 f3 02 	lds	r25, 0x02F3	; 0x8002f3 <xTickCount+0x1>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1480:	8c 0f       	add	r24, r28
    1482:	9d 1f       	adc	r25, r29
    1484:	0e 94 88 06 	call	0xd10	; 0xd10 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    1488:	df 91       	pop	r29
    148a:	cf 91       	pop	r28
    148c:	08 95       	ret

0000148e <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    148e:	0f 93       	push	r16
    1490:	1f 93       	push	r17
    1492:	cf 93       	push	r28
    1494:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1496:	dc 01       	movw	r26, r24
    1498:	15 96       	adiw	r26, 0x05	; 5
    149a:	ed 91       	ld	r30, X+
    149c:	fc 91       	ld	r31, X
    149e:	16 97       	sbiw	r26, 0x06	; 6
    14a0:	c6 81       	ldd	r28, Z+6	; 0x06
    14a2:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    14a4:	8e 01       	movw	r16, r28
    14a6:	04 5f       	subi	r16, 0xF4	; 244
    14a8:	1f 4f       	sbci	r17, 0xFF	; 255
    14aa:	c8 01       	movw	r24, r16
    14ac:	0e 94 70 01 	call	0x2e0	; 0x2e0 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    14b0:	80 91 ee 02 	lds	r24, 0x02EE	; 0x8002ee <uxSchedulerSuspended>
    14b4:	81 11       	cpse	r24, r1
    14b6:	1c c0       	rjmp	.+56     	; 0x14f0 <xTaskRemoveFromEventList+0x62>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    14b8:	0a 50       	subi	r16, 0x0A	; 10
    14ba:	11 09       	sbc	r17, r1
    14bc:	c8 01       	movw	r24, r16
    14be:	0e 94 70 01 	call	0x2e0	; 0x2e0 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    14c2:	8e 89       	ldd	r24, Y+22	; 0x16
    14c4:	90 91 f0 02 	lds	r25, 0x02F0	; 0x8002f0 <uxTopReadyPriority>
    14c8:	98 17       	cp	r25, r24
    14ca:	10 f4       	brcc	.+4      	; 0x14d0 <xTaskRemoveFromEventList+0x42>
    14cc:	80 93 f0 02 	sts	0x02F0, r24	; 0x8002f0 <uxTopReadyPriority>
    14d0:	90 e0       	ldi	r25, 0x00	; 0
    14d2:	9c 01       	movw	r18, r24
    14d4:	22 0f       	add	r18, r18
    14d6:	33 1f       	adc	r19, r19
    14d8:	22 0f       	add	r18, r18
    14da:	33 1f       	adc	r19, r19
    14dc:	22 0f       	add	r18, r18
    14de:	33 1f       	adc	r19, r19
    14e0:	82 0f       	add	r24, r18
    14e2:	93 1f       	adc	r25, r19
    14e4:	b8 01       	movw	r22, r16
    14e6:	82 5e       	subi	r24, 0xE2	; 226
    14e8:	9c 4f       	sbci	r25, 0xFC	; 252
    14ea:	0e 94 0e 01 	call	0x21c	; 0x21c <vListInsertEnd>
    14ee:	05 c0       	rjmp	.+10     	; 0x14fa <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    14f0:	b8 01       	movw	r22, r16
    14f2:	8f ef       	ldi	r24, 0xFF	; 255
    14f4:	92 e0       	ldi	r25, 0x02	; 2
    14f6:	0e 94 0e 01 	call	0x21c	; 0x21c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    14fa:	e0 91 4b 03 	lds	r30, 0x034B	; 0x80034b <pxCurrentTCB>
    14fe:	f0 91 4c 03 	lds	r31, 0x034C	; 0x80034c <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1502:	81 e0       	ldi	r24, 0x01	; 1
    1504:	2e 89       	ldd	r18, Y+22	; 0x16
    1506:	96 89       	ldd	r25, Z+22	; 0x16
    1508:	29 17       	cp	r18, r25
    150a:	08 f4       	brcc	.+2      	; 0x150e <xTaskRemoveFromEventList+0x80>
    150c:	80 e0       	ldi	r24, 0x00	; 0
}
    150e:	df 91       	pop	r29
    1510:	cf 91       	pop	r28
    1512:	1f 91       	pop	r17
    1514:	0f 91       	pop	r16
    1516:	08 95       	ret

00001518 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1518:	20 91 eb 02 	lds	r18, 0x02EB	; 0x8002eb <xNumOfOverflows>
    151c:	fc 01       	movw	r30, r24
    151e:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1520:	20 91 f2 02 	lds	r18, 0x02F2	; 0x8002f2 <xTickCount>
    1524:	30 91 f3 02 	lds	r19, 0x02F3	; 0x8002f3 <xTickCount+0x1>
    1528:	32 83       	std	Z+2, r19	; 0x02
    152a:	21 83       	std	Z+1, r18	; 0x01
    152c:	08 95       	ret

0000152e <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    152e:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1530:	0f b6       	in	r0, 0x3f	; 63
    1532:	f8 94       	cli
    1534:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1536:	80 91 eb 02 	lds	r24, 0x02EB	; 0x8002eb <xNumOfOverflows>
    153a:	90 81       	ld	r25, Z
    153c:	98 17       	cp	r25, r24
    153e:	49 f0       	breq	.+18     	; 0x1552 <xTaskCheckForTimeOut+0x24>
    1540:	80 91 f2 02 	lds	r24, 0x02F2	; 0x8002f2 <xTickCount>
    1544:	90 91 f3 02 	lds	r25, 0x02F3	; 0x8002f3 <xTickCount+0x1>
    1548:	21 81       	ldd	r18, Z+1	; 0x01
    154a:	32 81       	ldd	r19, Z+2	; 0x02
    154c:	82 17       	cp	r24, r18
    154e:	93 07       	cpc	r25, r19
    1550:	f8 f4       	brcc	.+62     	; 0x1590 <xTaskCheckForTimeOut+0x62>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1552:	80 91 f2 02 	lds	r24, 0x02F2	; 0x8002f2 <xTickCount>
    1556:	90 91 f3 02 	lds	r25, 0x02F3	; 0x8002f3 <xTickCount+0x1>
    155a:	41 81       	ldd	r20, Z+1	; 0x01
    155c:	52 81       	ldd	r21, Z+2	; 0x02
    155e:	db 01       	movw	r26, r22
    1560:	2d 91       	ld	r18, X+
    1562:	3c 91       	ld	r19, X
    1564:	11 97       	sbiw	r26, 0x01	; 1
    1566:	84 1b       	sub	r24, r20
    1568:	95 0b       	sbc	r25, r21
    156a:	82 17       	cp	r24, r18
    156c:	93 07       	cpc	r25, r19
    156e:	90 f4       	brcc	.+36     	; 0x1594 <xTaskCheckForTimeOut+0x66>
    1570:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1572:	e0 91 f2 02 	lds	r30, 0x02F2	; 0x8002f2 <xTickCount>
    1576:	f0 91 f3 02 	lds	r31, 0x02F3	; 0x8002f3 <xTickCount+0x1>
    157a:	bf 01       	movw	r22, r30
    157c:	64 1b       	sub	r22, r20
    157e:	75 0b       	sbc	r23, r21
    1580:	26 1b       	sub	r18, r22
    1582:	37 0b       	sbc	r19, r23
    1584:	2d 93       	st	X+, r18
    1586:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    1588:	0e 94 8c 0a 	call	0x1518	; 0x1518 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    158c:	80 e0       	ldi	r24, 0x00	; 0
    158e:	03 c0       	rjmp	.+6      	; 0x1596 <xTaskCheckForTimeOut+0x68>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1590:	81 e0       	ldi	r24, 0x01	; 1
    1592:	01 c0       	rjmp	.+2      	; 0x1596 <xTaskCheckForTimeOut+0x68>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1594:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1596:	0f 90       	pop	r0
    1598:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    159a:	08 95       	ret

0000159c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    159c:	81 e0       	ldi	r24, 0x01	; 1
    159e:	80 93 ec 02 	sts	0x02EC, r24	; 0x8002ec <xMissedYield>
    15a2:	08 95       	ret

000015a4 <__divmodhi4>:
    15a4:	97 fb       	bst	r25, 7
    15a6:	07 2e       	mov	r0, r23
    15a8:	16 f4       	brtc	.+4      	; 0x15ae <__divmodhi4+0xa>
    15aa:	00 94       	com	r0
    15ac:	07 d0       	rcall	.+14     	; 0x15bc <__divmodhi4_neg1>
    15ae:	77 fd       	sbrc	r23, 7
    15b0:	09 d0       	rcall	.+18     	; 0x15c4 <__divmodhi4_neg2>
    15b2:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <__udivmodhi4>
    15b6:	07 fc       	sbrc	r0, 7
    15b8:	05 d0       	rcall	.+10     	; 0x15c4 <__divmodhi4_neg2>
    15ba:	3e f4       	brtc	.+14     	; 0x15ca <__divmodhi4_exit>

000015bc <__divmodhi4_neg1>:
    15bc:	90 95       	com	r25
    15be:	81 95       	neg	r24
    15c0:	9f 4f       	sbci	r25, 0xFF	; 255
    15c2:	08 95       	ret

000015c4 <__divmodhi4_neg2>:
    15c4:	70 95       	com	r23
    15c6:	61 95       	neg	r22
    15c8:	7f 4f       	sbci	r23, 0xFF	; 255

000015ca <__divmodhi4_exit>:
    15ca:	08 95       	ret

000015cc <__udivmodhi4>:
    15cc:	aa 1b       	sub	r26, r26
    15ce:	bb 1b       	sub	r27, r27
    15d0:	51 e1       	ldi	r21, 0x11	; 17
    15d2:	07 c0       	rjmp	.+14     	; 0x15e2 <__udivmodhi4_ep>

000015d4 <__udivmodhi4_loop>:
    15d4:	aa 1f       	adc	r26, r26
    15d6:	bb 1f       	adc	r27, r27
    15d8:	a6 17       	cp	r26, r22
    15da:	b7 07       	cpc	r27, r23
    15dc:	10 f0       	brcs	.+4      	; 0x15e2 <__udivmodhi4_ep>
    15de:	a6 1b       	sub	r26, r22
    15e0:	b7 0b       	sbc	r27, r23

000015e2 <__udivmodhi4_ep>:
    15e2:	88 1f       	adc	r24, r24
    15e4:	99 1f       	adc	r25, r25
    15e6:	5a 95       	dec	r21
    15e8:	a9 f7       	brne	.-22     	; 0x15d4 <__udivmodhi4_loop>
    15ea:	80 95       	com	r24
    15ec:	90 95       	com	r25
    15ee:	bc 01       	movw	r22, r24
    15f0:	cd 01       	movw	r24, r26
    15f2:	08 95       	ret

000015f4 <memcpy>:
    15f4:	fb 01       	movw	r30, r22
    15f6:	dc 01       	movw	r26, r24
    15f8:	02 c0       	rjmp	.+4      	; 0x15fe <memcpy+0xa>
    15fa:	01 90       	ld	r0, Z+
    15fc:	0d 92       	st	X+, r0
    15fe:	41 50       	subi	r20, 0x01	; 1
    1600:	50 40       	sbci	r21, 0x00	; 0
    1602:	d8 f7       	brcc	.-10     	; 0x15fa <memcpy+0x6>
    1604:	08 95       	ret

00001606 <memset>:
    1606:	dc 01       	movw	r26, r24
    1608:	01 c0       	rjmp	.+2      	; 0x160c <memset+0x6>
    160a:	6d 93       	st	X+, r22
    160c:	41 50       	subi	r20, 0x01	; 1
    160e:	50 40       	sbci	r21, 0x00	; 0
    1610:	e0 f7       	brcc	.-8      	; 0x160a <memset+0x4>
    1612:	08 95       	ret

00001614 <strncpy>:
    1614:	fb 01       	movw	r30, r22
    1616:	dc 01       	movw	r26, r24
    1618:	41 50       	subi	r20, 0x01	; 1
    161a:	50 40       	sbci	r21, 0x00	; 0
    161c:	48 f0       	brcs	.+18     	; 0x1630 <strncpy+0x1c>
    161e:	01 90       	ld	r0, Z+
    1620:	0d 92       	st	X+, r0
    1622:	00 20       	and	r0, r0
    1624:	c9 f7       	brne	.-14     	; 0x1618 <strncpy+0x4>
    1626:	01 c0       	rjmp	.+2      	; 0x162a <strncpy+0x16>
    1628:	1d 92       	st	X+, r1
    162a:	41 50       	subi	r20, 0x01	; 1
    162c:	50 40       	sbci	r21, 0x00	; 0
    162e:	e0 f7       	brcc	.-8      	; 0x1628 <strncpy+0x14>
    1630:	08 95       	ret

00001632 <_exit>:
    1632:	f8 94       	cli

00001634 <__stop_program>:
    1634:	ff cf       	rjmp	.-2      	; 0x1634 <__stop_program>
